{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83d\udcda Holo-fn","text":"<p>A minimal functional library for TypeScript featuring monads like <code>Maybe</code>, <code>Either</code> and <code>Result</code>. Built for composability and Rambda compatibility.</p> <p>\ud83d\udca1 Designed to work seamlessly with <code>pipe</code> from Rambda. Fully typed, immutable, and safe by default.</p> <p>Below you will find detailed explanations, examples, and usage instructions to help you get started with holo-fn.</p>"},{"location":"#table-of-contents","title":"\u2728 Table of Contents","text":"<ul> <li>Introduction</li> <li>Features</li> <li>Getting Started</li> <li>API Reference<ul> <li>Maybe</li> <li>Either</li> <li>Result</li> </ul> </li> <li>Contributing</li> <li>Changelog</li> </ul>"},{"location":"#introduction","title":"\ud83d\udca1 Introduction","text":"<p>holo-fn is a minimal functional library designed for TypeScript with full support for monads and functional programming principles. It includes commonly used monads like <code>Maybe</code>, <code>Either</code>, and <code>Result</code> for safe and composable functional programming.</p> <ul> <li>Designed to work seamlessly with <code>pipe</code> from <code>Rambda</code>.</li> <li>Fully typed, immutable by default, and safe for modern TypeScript development.</li> </ul>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\u2705 Functional types: <code>Maybe</code>, <code>Either</code>, <code>Result</code></li> <li>\u2699\ufe0f Pipe-friendly (Rambda/Ramda compatible)</li> <li>\ud83d\udd12 Immutable by default</li> <li>\ud83e\uddea 100% test coverage</li> <li>\u26a1\ufe0f Zero dependencies</li> <li>\ud83e\udde0 Full TypeScript inference</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#110-2025-11-30","title":"[1.1.0] - 2025-11-30","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li><code>filter</code> method for <code>Maybe</code>: Validates values with a predicate, converting <code>Just</code> to <code>Nothing</code> when the predicate fails.</li> <li>Added <code>filter(predicate: (value: T) =&gt; boolean): Maybe&lt;T&gt;</code> method to <code>Maybe</code> interface.</li> <li>Added curried <code>filter</code> function for use with <code>pipe</code>.</li> <li> <p>Example:   <pre><code>just(25).filter(x =&gt; x &gt;= 18).unwrapOr(0); // 25\njust(15).filter(x =&gt; x &gt;= 18).unwrapOr(0); // 0\n</code></pre></p> </li> <li> <p><code>validate</code> method for <code>Result</code> and <code>Either</code>: Validates values with custom error messages.</p> </li> <li>Added <code>validate(predicate: (value: T) =&gt; boolean, error: E): Result&lt;T, E&gt;</code> to <code>Result</code>.</li> <li>Added <code>validate(predicate: (value: R) =&gt; boolean, leftValue: L): Either&lt;L, R&gt;</code> to <code>Either</code>.</li> <li>Added curried <code>validate</code> functions for use with <code>pipe</code>.</li> <li>Example:   <pre><code>ok(25).validate(x =&gt; x &gt;= 18, 'Must be 18+').unwrapOr(0); // 25\nok(15).validate(x =&gt; x &gt;= 18, 'Must be 18+').isErr(); // true\n</code></pre></li> </ul>"},{"location":"changelog/#100-2025-06-25","title":"[1.0.0] - 2025-06-25","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>First stable release of <code>holo-fn</code> with core monads: <code>Maybe</code>, <code>Either</code>, and <code>Result</code>.</li> <li><code>Maybe</code> monad:</li> <li><code>Just</code>, <code>Nothing</code>, and helper functions like <code>fromNullable</code>.</li> <li>Added methods like <code>map</code>, <code>chain</code>, <code>unwrapOr</code>, <code>match</code>, and <code>equals</code>.</li> <li><code>Either</code> monad:</li> <li><code>Left</code>, 'Right', and helper functions like <code>tryCatch</code>, <code>fromPromise</code>, <code>fromAsync</code>.</li> <li>Added methods like <code>map</code>, <code>chain</code>, <code>unwrapOr</code>, <code>match</code>, and <code>equals</code>.</li> <li><code>Result</code> monad:</li> <li><code>Ok</code>, <code>Err</code>, and helper functions like <code>fromThrowable</code>, <code>fromPromise</code>, <code>fromAsync</code>.</li> <li>Added methods like <code>map</code>, <code>chain</code>, <code>unwrapOr</code>, <code>match</code>, and <code>equals</code>.</li> <li>Introduced <code>curried functions</code> for <code>map</code>, <code>chain</code>, <code>unwrapOr</code>, and <code>match</code> for each monad:</li> <li><code>map</code>, <code>chain</code>, <code>unwrapOr</code>, and <code>match</code> for <code>Either</code>, <code>Maybe</code> and <code>Result</code>.</li> <li><code>Export restructuring</code>:</li> <li>Now, monads are imported from their specific files, instead of a global import.</li> <li>Example:   <pre><code>import { M, E, R } from \"holo-fn\";\nimport { fromNullable } from 'holo-fn/maybe';\nimport { tryCatch } from 'holo-fn/either';\nimport { fromThrowable } from 'holo-fn/result';\n</code></pre></li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li><code>Migration to Bun</code>: The library is now compatible with <code>Bun</code> runtime, offering better performance and faster execution.</li> <li>Reorganized the imports for better modularization and performance.</li> <li>Now, to use specific monads and functions, you must import from their respective files.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fixed <code>bug</code> related to circular imports.</li> <li>Optimized the library for faster loading and reduced bundle size.</li> </ul>"},{"location":"changelog/#030-2025-05-10","title":"[0.3.0] - 2025-05-10","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>New helpers functions:</li> <li>Maybe:<ul> <li>just(value: T): Maybe: Creates a <code>Just</code> value representing the presence of a value. <li>nothing(): Maybe: Creates a <code>Nothing</code> value representing the absence of a value. <li>Either:<ul> <li>left(value: L): Either: Creates a <code>Left</code> value representing a failure or error. <li>right(value: R): Either: Creates a <code>Right</code> value representing a success. <li>Result:<ul> <li>ok(value: T): Result: Creates an <code>Ok</code> value representing the success of an operation with a value. <li>err(error: E): Result: Creates an <code>Err</code> value representing a failure of an operation with an error."},{"location":"changelog/#020-2025-04-26","title":"[0.2.0] - 2025-04-26","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Introduced the <code>equals</code> method for Maybe, Either, and Result types to compare instances of these types based on their internal values.</li> <li>Added curried functions for <code>equals</code> to allow for easier composition and usage:</li> <li><code>equalsM</code> for Maybe.</li> <li><code>equalsE</code> for Either.</li> <li><code>equalsR</code> for Result.</li> <li>New helper functions for easy comparison between monadic values.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Refined the API for better type inference and consistency across all functional types (<code>Maybe</code>, <code>Either</code>, <code>Result</code>).</li> <li>Improved type safety for curried functions in all monads.</li> </ul>"},{"location":"changelog/#010-2025-04-23","title":"[0.1.0] - 2025-04-23","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Initial release of holo-fn with core monads: <code>Maybe</code>, <code>Either</code>, and <code>Result</code>.</li> <li><code>Maybe</code> monad: <code>Just</code>, <code>Nothing</code>, and helper functions like <code>fromNullable</code>.</li> <li><code>Either</code> monad: <code>Left</code>, <code>Right</code>, <code>tryCatch</code>, <code>fromPromise</code>, <code>fromAsync</code>.</li> <li><code>Result</code> monad: <code>Ok</code>, <code>Err</code>, <code>fromThrowable</code>, <code>fromPromise</code>, <code>fromAsync</code>.</li> <li>Added curried handlers for <code>map</code>, <code>chain</code>, <code>unwrapOr</code>, and <code>match</code> for better composition and functional pipelines:</li> <li><code>mapE</code>, <code>chainE</code>, <code>unwrapOrE</code>, and <code>matchE</code> for <code>Either</code>.</li> <li><code>mapM</code>, <code>chainM</code>, <code>unwrapOrM</code>, and <code>matchM</code> for <code>Maybe</code>.</li> <li><code>mapR</code>, <code>chainR</code>, <code>unwrapOrR</code>, and <code>matchR</code> for <code>Result</code>.</li> </ul>"},{"location":"contributing/","title":"Contributing to holo-fn","text":"<p>Thank you for your interest in contributing to holo-fn! To keep things organized and make it easier for you to get involved, please read through the guidelines below.</p>"},{"location":"contributing/#setup","title":"\ud83d\ude80 Setup","text":""},{"location":"contributing/#1-install-dependencies","title":"1. Install Dependencies","text":"<p>To get started, clone the repository and install the dependencies:</p> <pre><code>git clone https://github.com/yourusername/holo-fn.git\ncd holo-fn\nbun install\n</code></pre>"},{"location":"contributing/#2-running-tests-and-coverage","title":"2. Running Tests and Coverage","text":"<p>You can run the tests using Jest to ensure everything works as expected:</p> <pre><code>bun run test\n</code></pre> <p>To convert the coverage into an HTML report, run:</p> <pre><code>bun run coverage:html\n</code></pre>"},{"location":"contributing/#building","title":"\ud83d\udce6 Building","text":"<p>To build the project:</p> <pre><code>bun run build\n</code></pre>"},{"location":"contributing/#testing-locally","title":"\ud83e\uddf0 Testing Locally","text":"<p>To test your changes locally before publishing or linking the library:</p> <ol> <li> <p>Build the Library:</p> </li> <li> <p>Run the following to build the project and prepare the files for testing:   <pre><code>bun run build\n</code></pre></p> </li> <li> <p>Pack the Library:</p> </li> <li> <p>After building, run npm pack to create a .tgz file that you can install locally:   <pre><code>bun pm pack\n</code></pre></p> </li> <li> <p>Install Locally in Your Test Project:</p> </li> <li> <p>In the project where you want to test the library, run the following:   <pre><code>npm install /path/to/holo-fn-&lt;version&gt;.tgz\n</code></pre></p> </li> <li> <p>This will install the library locally in your project, and you can import and use it as if it were an npm package.</p> </li> </ol>"},{"location":"contributing/#how-to-contribute","title":"\ud83e\udd1d How to Contribute","text":"<ol> <li>Fork the repository to your GitHub account and clone it locally.</li> <li>Create a new branch for your feature or fix:    <pre><code>git checkout -b feat/issue-number-or-short-description\n</code></pre></li> <li>Make your changes: add your feature or fix the bug.</li> <li>Commit your changes:    <pre><code>git commit -am 'feat: add new feature'  # or 'fix: resolve issue'\n</code></pre></li> <li>Push to your fork:    <pre><code>git push origin feat/issue-number-or-short-description\n</code></pre></li> <li>Create a pull request from your fork to the main repository.</li> </ol>"},{"location":"contributing/#guidelines","title":"\ud83c\udfaf Guidelines","text":"<ul> <li>Please write clear commit messages.</li> <li>Ensure all code is properly tested.</li> <li>Follow the code style used in the project.</li> </ul> <p>Thank you for contributing! \ud83d\ude80</p>"},{"location":"future_features/","title":"Futuras Features para holo-fn","text":"<p>Este documento cont\u00e9m ideias de novas funcionalidades para a biblioteca holo-fn.</p>"},{"location":"future_features/#1-validacao-e-parsing","title":"1. Valida\u00e7\u00e3o e Parsing","text":"<p><pre><code>validate&lt;T&gt;(predicate: (value: T) =&gt; boolean): Maybe&lt;T&gt;\nfilter&lt;T&gt;(predicate: (value: T) =&gt; boolean): Maybe&lt;T&gt;\nvalidateWith&lt;T, E&gt;(value: T, predicate: (v: T) =&gt; boolean, error: E): Either&lt;E, T&gt;\n</code></pre> \u00datil para valida\u00e7\u00f5es de dados de formul\u00e1rios, APIs, etc.</p>"},{"location":"future_features/#2-combinadoresagregadores","title":"2. Combinadores/Agregadores","text":"<p><pre><code>all&lt;T&gt;(maybes: Maybe&lt;T&gt;[]): Maybe&lt;T[]&gt;\nany&lt;T&gt;(maybes: Maybe&lt;T&gt;[]): Maybe&lt;T&gt;\nsequence&lt;T&gt;(maybes: Maybe&lt;T&gt;[]): Maybe&lt;T[]&gt;\ntraverse&lt;T, U&gt;(fn: (x: T) =&gt; Maybe&lt;U&gt;, arr: T[]): Maybe&lt;U[]&gt;\npartition&lt;L, R&gt;(eithers: Either&lt;L, R&gt;[]): { lefts: L[], rights: R[] }\n</code></pre> Essencial para trabalhar com listas de opera\u00e7\u00f5es que podem falhar.</p>"},{"location":"future_features/#3-conversoes-entre-tipos","title":"3. Convers\u00f5es entre tipos","text":"<p><pre><code>maybeToEither&lt;L, R&gt;(maybe: Maybe&lt;R&gt;, leftValue: L): Either&lt;L, R&gt;\nmaybeToResult&lt;T, E&gt;(maybe: Maybe&lt;T&gt;, error: E): Result&lt;T, E&gt;\neitherToResult&lt;T, E&gt;(either: Either&lt;E, T&gt;): Result&lt;T, E&gt;\nresultToEither&lt;T, E&gt;(result: Result&lt;T, E&gt;): Either&lt;E, T&gt;\n</code></pre> Facilita a interoperabilidade entre os tr\u00eas tipos de monads.</p>"},{"location":"future_features/#4-utilitarios-async-avancados","title":"4. Utilit\u00e1rios Async Avan\u00e7ados","text":"<pre><code>retryWithBackoff&lt;T, E&gt;(fn: () =&gt; Promise&lt;T&gt;, options: { maxRetries: number, delayMs: number }): Promise&lt;Result&lt;T, E&gt;&gt;\nwithTimeout&lt;T, E&gt;(promise: Promise&lt;T&gt;, timeoutMs: number, error: E): Promise&lt;Result&lt;T, E&gt;&gt;\nallSettled&lt;T, E&gt;(promises: Promise&lt;T&gt;[]): Promise&lt;Result&lt;T, E&gt;[]&gt;\n</code></pre>"},{"location":"future_features/#5-pattern-matching-estendido","title":"5. Pattern Matching Estendido","text":"<pre><code>matchMany([maybe1, maybe2], { allJust: (v1, v2) =&gt; ..., someNothing: () =&gt; ... })\nmatchWith(value, [[predicate1, handler1], [predicate2, handler2], [() =&gt; true, defaultHandler]])\n</code></pre>"},{"location":"future_features/#6-debuglogging-helpers","title":"6. Debug/Logging Helpers","text":"<p><pre><code>tap&lt;T&gt;(fn: (value: T) =&gt; void): (maybe: Maybe&lt;T&gt;) =&gt; Maybe&lt;T&gt;\ninspect&lt;T&gt;(label?: string): (maybe: Maybe&lt;T&gt;) =&gt; Maybe&lt;T&gt;\n</code></pre> Para facilitar debugging em pipelines funcionais.</p>"},{"location":"future_features/#7-utilitarios-para-objetos","title":"7. Utilit\u00e1rios para Objetos","text":"<pre><code>mapProps&lt;T extends object, K extends keyof T&gt;(obj: T, key: K, fn: (v: T[K]) =&gt; T[K]): Maybe&lt;T&gt;\ngetPath&lt;T&gt;(obj: unknown, path: string[]): Maybe&lt;T&gt;\n</code></pre>"},{"location":"future_features/#8-monoidsemigroup-support","title":"8. Monoid/Semigroup Support","text":"<pre><code>combine&lt;T&gt;(maybe1: Maybe&lt;T&gt;, maybe2: Maybe&lt;T&gt;, combiner: (a: T, b: T) =&gt; T): Maybe&lt;T&gt;\nconcat&lt;T&gt;(maybes: Maybe&lt;T&gt;[]): Maybe&lt;T&gt;\n</code></pre>"},{"location":"future_features/#9-lazy-evaluation","title":"9. Lazy Evaluation","text":"<pre><code>lazy&lt;T&gt;(thunk: () =&gt; Maybe&lt;T&gt;): LazyMaybe&lt;T&gt;\n</code></pre>"},{"location":"future_features/#10-json-serialization","title":"10. JSON Serialization","text":"<pre><code>toJSON&lt;T&gt;(maybe: Maybe&lt;T&gt;): { type: 'Just' | 'Nothing', value?: T }\nfromJSON&lt;T&gt;(json: any): Maybe&lt;T&gt;\n</code></pre>"},{"location":"future_features/#prioridades","title":"Prioridades","text":"<ol> <li>Combinadores (all/sequence) - Muito comum trabalhar com listas de opera\u00e7\u00f5es</li> <li>Convers\u00f5es entre tipos - Aumenta a flexibilidade da biblioteca</li> <li>Valida\u00e7\u00e3o/Filter - Caso de uso extremamente comum</li> </ol>"},{"location":"getting_started/","title":"\ud83d\ude80 Getting Started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>To install holo-fn in your project, use the following npm command:</p> <pre><code>npm install holo-fn\n</code></pre>"},{"location":"getting_started/#importing","title":"Importing","text":"<p>You can import specific monads or helpers as needed:</p> <pre><code>import { M, E, R } from \"holo-fn\"\nimport { fromNullable } from 'holo-fn/maybe'\nimport { tryCatch } from 'holo-fn/either'\nimport { fromThrowable } from 'holo-fn/result'\n</code></pre>"},{"location":"getting_started/#api-reference","title":"\ud83d\udce6 API Reference","text":"<ul> <li>Maybe</li> <li>Either</li> <li>Result</li> </ul>"},{"location":"getting_started/#comparison-between-maybe-either-and-result","title":"\ud83d\udcda Comparison between Maybe, Either, and Result","text":"Aspect Maybe Either Result Purpose Represents a value that may be <code>null</code> or <code>undefined</code>. Represents an operation that can either succeed (<code>Right</code>) or fail (<code>Left</code>). Represents the result of an operation, which can either succeed (<code>Ok</code>) or fail with an error (<code>Err</code>). Types <code>Just&lt;T&gt;</code>, <code>Nothing</code> <code>Right&lt;R&gt;</code>, <code>Left&lt;L&gt;</code> <code>Ok&lt;T&gt;</code>, <code>Err&lt;E&gt;</code> Composition (map, chain) Supports <code>map</code>, <code>chain</code> for simple compositions. Supports <code>map</code>, <code>chain</code> for compositions involving success or failure. Supports <code>map</code>, <code>chain</code> for manipulating values or errors. Method to Access Value <code>getOrElse(defaultValue)</code> <code>getOrElse(defaultValue)</code> <code>unwrapOr(defaultValue)</code> Method for Success Case <code>isJust()</code>, <code>isNothing()</code> <code>isRight()</code>, <code>isLeft()</code> <code>isOk()</code>, <code>isErr()</code> Usage Example <code>fromNullable(value)</code> <code>new Right(value)</code> or <code>new Left(error)</code> <code>new Ok(value)</code> or <code>new Err(error)</code> When to Use When there is an optional value that may be <code>null</code> or <code>undefined</code>. When an operation can succeed or fail, and it is important to distinguish between them. When you need to clearly distinguish between success or failure in an operation. Common Helpers <code>fromNullable</code> <code>tryCatch</code>, <code>fromPromise</code> <code>fromThrowable</code>, <code>fromPromise</code>, <code>fromAsync</code> Example of <code>map</code> <code>maybeValue.map(value =&gt; value * 2)</code> <code>eitherValue.map(value =&gt; value * 2)</code> <code>resultValue.map(value =&gt; value * 2)</code> Example of <code>chain</code> <code>maybeValue.chain(value =&gt; fromNullable(value))</code> <code>eitherValue.chain(value =&gt; new Right(value))</code> <code>resultValue.chain(value =&gt; new Ok(value))</code>"},{"location":"getting_started/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in here.</p>"},{"location":"getting_started/#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions to holo-fn! Please refer to the CONTRIBUTING.md for detailed instructions on how to run tests, build the library, and contribute.</p>"},{"location":"getting_started/#license","title":"\ud83d\udcdc License","text":"<p>MIT</p>"},{"location":"either/","title":"<code>Either&lt;L, R&gt;</code>","text":"<p><code>Either</code> is used for computations that may fail. It is either a <code>Left&lt;L&gt;</code> (error) or a <code>Right&lt;R&gt;</code> (success).</p> <pre><code>import { Right } from 'holo-fn/either'\n\nconst result = new Right(10)\n  .map(n =&gt; n * 2)\n  .unwrapOr(0)\n\nconsole.log(result); // 20\n</code></pre>"},{"location":"either/#methods","title":"Methods","text":""},{"location":"either/#mapfn-value-r-u-eitherl-u","title":"<code>map(fn: (value: R) =&gt; U): Either&lt;L, U&gt;</code>","text":"<p>Maps over the <code>Right</code> value. Does nothing for <code>Left</code>.</p> <pre><code>import { Either, Left, Right } from \"holo-fn/either\";\n\nconst calculate = (a: number, b: number): Either&lt;string, number&gt; =&gt; {\n  if (b === 0) {\n    return new Left(\"Division by zero\");\n  }\n\n  return new Right(a / b);\n};\n\nconst result1 = calculate(10, 2)\n  .map(n =&gt; n * 2)\n  .unwrapOr(0);\n\nconsole.log(result1); // 10\n\nconst result2 = calculate(10, 0)\n  .map(n =&gt; n * 2)\n  .unwrapOr(0);\n\nconsole.log(result2); // 0\n</code></pre>"},{"location":"either/#mapleftmfn-err-l-m-eitherm-r","title":"<code>mapLeft&lt;M&gt;(fn: (err: L) =&gt; M): Either&lt;M, R&gt;</code>","text":"<p>Maps over the <code>Left</code> value. Does nothing for <code>Right</code>.</p> <pre><code>import { Either, Left, Right } from \"holo-fn/either\";\n\nconst calculate = (a: number, b: number): Either&lt;string, number&gt; =&gt; {\n  if (b === 0) {\n    return new Left(\"Division by zero\");\n  }\n\n  return new Right(a / b);\n};\n\nconst result1 = calculate(10, 2)\n  .map(n =&gt; n * 2)\n  .mapLeft(e =&gt; console.log(`Error: ${e}`)) // No printing here\n  .unwrapOr(0);\n\nconsole.log(result1); // 10\n\nconst result2 = calculate(10, 0)\n  .map(n =&gt; n * 2)\n  .mapLeft(e =&gt; console.log(`Error: ${e}`)) // Prints \"Error: Division by zero\"\n  .unwrapOr(0);\n\nconsole.log(result2); // 0\n</code></pre>"},{"location":"either/#chainfn-value-r-eitherl-u-eitherl-u","title":"<code>chain(fn: (value: R) =&gt; Either&lt;L, U&gt;): Either&lt;L, U&gt;</code>","text":"<p>Chains the transformation if the value is <code>Right</code>. Returns <code>Left</code> otherwise.</p> <pre><code>import { Either, Left, Right } from \"holo-fn/either\";\n\nconst calculate = (a: number, b: number): Either&lt;string, number&gt; =&gt; {\n  if (b === 0) {\n    return new Left(\"Division by zero\");\n  }\n\n  return new Right(a / b);\n};\n\nconst result1 = calculate(12, 2)\n  .chain(n =&gt; n &gt; 5 ? new Right(n * 2) : new Left(\"Result is too small\"))\n  .map(n =&gt; n + 1)\n  .mapLeft(e =&gt; console.log(`Error: ${e}`)) // Not run\n  .unwrapOr(0);\n\n\nconsole.log(result1); // 13\n\nconst result2 = calculate(10, 2)\n  .chain(n =&gt; n &gt; 5 ? new Right(n * 2) : new Left(\"Result is too small\"))\n  .map(n =&gt; n + 1)\n  .mapLeft(e =&gt; console.log(`Error: ${e}`)) // Prints \"Error: Result is too small\"\n  .unwrapOr(0);\n</code></pre>"},{"location":"either/#validatepredicate-value-r-boolean-leftvalue-l-eitherl-r","title":"<code>validate(predicate: (value: R) =&gt; boolean, leftValue: L): Either&lt;L, R&gt;</code>","text":"<p>Validates the <code>Right</code> value based on a predicate. If the predicate returns <code>true</code>, keeps the value. If it returns <code>false</code>, converts to <code>Left</code> with the provided error. Does nothing for <code>Left</code>.</p> <pre><code>import { Left, Right } from 'holo-fn/either';\n\nconst result1 = new Right&lt;string, number&gt;(25).validate((n) =&gt; n &gt;= 18, 'Must be 18+');\nconsole.log(result1.unwrapOr(0)); // 25\n\nconst result2 = new Right&lt;string, number&gt;(15).validate((n) =&gt; n &gt;= 18, 'Must be 18+');\nconsole.log(result2.isLeft()); // true\nconsole.log(result2.unwrapOr(0)); // 0\n\nconst result3 = new Left&lt;string, number&gt;('Already failed').validate((n) =&gt; n &gt;= 18, 'Must be 18+');\nconsole.log(result3.isLeft()); // true (keeps original error)\n</code></pre>"},{"location":"either/#unwrapordefaultvalue-r-r","title":"<code>unwrapOr(defaultValue: R): R</code>","text":"<p>Returns the value of <code>Right</code>, or the default value for <code>Left</code>.</p> <pre><code>import { Either, Left, Right } from \"holo-fn/either\";\n\nconst calculate = (a: number, b: number): Either&lt;string, number&gt; =&gt; {\n  if (b === 0) {\n    return new Left(\"Division by zero\");\n  }\n\n  return new Right(a / b);\n};\n\nconst result1 = calculate(12, 2).unwrapOr(0);\nconsole.log(result1); // 6\n\nconst result2 = calculate(10, 0).unwrapOr(-1);\nconsole.log(result2); // -1\n</code></pre>"},{"location":"either/#isright-boolean","title":"<code>isRight(): boolean</code>","text":"<p>Checks if the value is <code>Right</code>.</p> <pre><code>import { Either, Left, Right } from \"holo-fn/either\";\n\nconst calculate = (a: number, b: number): Either&lt;string, number&gt; =&gt; {\n  if (b === 0) {\n    return new Left(\"Division by zero\");\n  }\n\n  return new Right(a / b);\n};\n\nconst result1 = calculate(12, 2).isRight();\nconsole.log(result1); // true\n\nconst result2 = calculate(10, 0).isRight();\nconsole.log(result2); // false\n</code></pre>"},{"location":"either/#isleft-boolean","title":"<code>isLeft(): boolean</code>","text":"<p>Checks if the value is <code>Left</code>.</p> <pre><code>import { Either, Left, Right } from \"holo-fn/either\";\n\nconst calculate = (a: number, b: number): Either&lt;string, number&gt; =&gt; {\n  if (b === 0) {\n    return new Left(\"Division by zero\");\n  }\n\n  return new Right(a / b);\n};\n\nconst result1 = calculate(12, 2).isLeft();\nconsole.log(result1); // false\n\nconst result2 = calculate(10, 0).isLeft();\nconsole.log(result2); // true\n</code></pre>"},{"location":"either/#matchtcases-left-left-l-t-right-right-r-t-t","title":"<code>match&lt;T&gt;(cases: { left: (left: L) =&gt; T; right: (right: R) =&gt; T }): T</code>","text":"<p>Matches the value to execute either the <code>left</code> or <code>right</code> case.</p> <pre><code>import { Either, Left, Right } from \"holo-fn/either\";\n\nconst calculate = (a: number, b: number): Either&lt;string, number&gt; =&gt; {\n  if (b === 0) {\n    return new Left(\"Division by zero\");\n  }\n\n  return new Right(a / b);\n};\n\nconst result1 = calculate(12, 2)\n  .chain(n =&gt; n &gt; 5 ? new Right(n * 2) : new Left(\"Result is too small\"))\n  .map(n =&gt; n + 1)\n  .match({\n    right: n =&gt; n,\n    left: e =&gt; {\n      console.log(`Error: ${e}`); // Not run\n      return 0;\n    }\n  });\n\nconsole.log(result1); // 13\n\nconst result2 = calculate(10, 2)\n  .chain(n =&gt; n &gt; 5 ? new Right(n * 2) : new Left(\"Result is too small\"))\n  .map(n =&gt; n + 1)\n  .match({\n    right: n =&gt; n,\n    left: e =&gt; {\n      console.log(`Error: ${e}`); // Prints \"Error: Result is too small\"\n      return 0;\n    }\n  });\n\nconsole.log(result2); // 0\n</code></pre>"},{"location":"either/#equalsother-eitherl-r-boolean","title":"<code>equals(other: Either&lt;L, R&gt;): boolean</code>","text":"<p>Compares <code>this</code> to another <code>Either</code>, returns <code>false</code> if the values inside are different.</p> <pre><code>import { Either, Left, Right } from \"holo-fn/either\";\n\nconst calculate = (a: number, b: number): Either&lt;string, number&gt; =&gt; {\n  if (b === 0) {\n    return new Left(\"Division by zero\");\n  }\n\n  return new Right(a / b);\n};\n\nconst result1 = calculate(12, 2)\n  .chain(n =&gt; n &gt; 5 ? new Right(n * 2) : new Left(\"Result is too small\"))\n  .map(n =&gt; n + 1);\n\nconsole.log(result1.equals(new Right(13))); // true\n\nconst result2 = calculate(10, 2)\n  .chain(n =&gt; n &gt; 5 ? new Right(n * 2) : new Left(\"Result is too small\"))\n  .map(n =&gt; n + 1);\n\nconsole.log(result2.equals(new Right(0))); // false\n</code></pre>"},{"location":"either/#helpers","title":"Helpers","text":""},{"location":"either/#leftl-r-nevervalue-l-eitherl-r","title":"<code>left&lt;L, R = never&gt;(value: L): Either&lt;L, R&gt;</code>","text":"<p>Creates a <code>Left</code> value, representing an error or failure in an operation.</p> <pre><code>import { left } from 'holo-fn/either';\n\nconst eitherValue = left&lt;string, string&gt;(\"Error\");\nconsole.log(eitherValue.unwrapOr(\"No error\")); // \"No error\"\n</code></pre>"},{"location":"either/#rightl-rvalue-r-eitherl-r","title":"<code>right&lt;L, R&gt;(value: R): Either&lt;L, R&gt;</code>","text":"<p>Creates a <code>Right</code> value, representing a success in an operation.</p> <pre><code>import { right } from 'holo-fn/either';\n\nconst eitherValue = right(10);\nconsole.log(eitherValue.unwrapOr(0)); // 10\n</code></pre>"},{"location":"either/#trycatchfn-onerror","title":"<code>tryCatch(fn, onError?)</code>","text":"<p>Wraps a potentially throwing function in an <code>Either</code>.</p> <pre><code>import { tryCatch } from 'holo-fn/either';\n\nconst input = '{\"name\": \"John Doe\"}'\n\ninterface User {\n    name: string;\n}\n\nconst convertToJson = (obj: unknown): User =&gt; {\n  if (typeof obj === 'object' &amp;&amp; obj !== null &amp;&amp; 'name' in obj) {\n    return obj as User;\n  }\n\n  return { name: 'anonymous' };\n}\n\nconst parsed = tryCatch(() =&gt; JSON.parse(input), e =&gt; 'Invalid JSON')\n  .map(convertToJson)\n  .unwrapOr({ name: 'anonymous 1' });\n\nconsole.log(parsed.name) // John Doe\n</code></pre> <ul> <li>Returns <code>Right&lt;R&gt;</code> if <code>fn()</code> succeeds</li> <li>Returns <code>Left&lt;L&gt;</code> if it throws, using <code>onError</code> if provided</li> </ul>"},{"location":"either/#frompromisepromise-onerror","title":"<code>fromPromise(promise, onError?)</code>","text":"<p>Wraps a <code>Promise&lt;T&gt;</code> into a <code>Promise&lt;Either&lt;L, R&gt;&gt;</code>.</p> <pre><code>import { fromPromise } from 'holo-fn/either'\n\nconst result = await fromPromise(fetch('/api'), e =&gt; 'Network error')\n\nconsole.log(result) // _Left { value: 'Network error' }\n</code></pre> <ul> <li>Resolves to <code>Right&lt;R&gt;</code> on success</li> <li>Resolves to <code>Left&lt;L&gt;</code> on failure</li> </ul>"},{"location":"either/#fromasyncfn-onerror","title":"<code>fromAsync(fn, onError?)</code>","text":"<p>Same as <code>fromPromise</code>, but lazy \u2014 receives a function returning a Promise.</p> <pre><code>import { fromAsync } from 'holo-fn/either'\n\nconst result = await fromAsync(async () =&gt; await fetch('/api'), e =&gt; 'Request failed')\n\nconsole.log(result) // _Left { value: 'Request failed' }\n</code></pre> <ul> <li>Allows deferred execution</li> <li>Handles exceptions from <code>async () =&gt; ...</code></li> </ul>"},{"location":"either/#curried-helpers","title":"Curried Helpers","text":""},{"location":"either/#map","title":"<code>map</code>","text":"<p>Curried version of <code>map</code> for <code>Either</code>. This allows functional composition with <code>pipe</code>.</p> <pre><code>import { map, Right } from 'holo-fn/either';\n\nconst result = pipe(\n  new Right(5),\n  map((x) =&gt; x * 2),\n  (res) =&gt; res.unwrapOr(0)\n);\n\nconsole.log(result); // 10\n</code></pre>"},{"location":"either/#mapleft","title":"<code>mapLeft</code>","text":"<p>Curried version of <code>mapLeft</code> for <code>Either</code>. This allows mapping over the Left value in a functional pipeline.</p> <pre><code>import { Left, mapLeft } from 'holo-fn/either';\n\nconst result = pipe(\n  new Left&lt;string, string&gt;(\"Error\"),\n  mapLeft((e) =&gt; `Mapped error: ${e}`),\n  (res) =&gt; res.unwrapOr(\"No value\") \n);\n\nconsole.log(result); // \"No value\"\n</code></pre>"},{"location":"either/#chain","title":"<code>chain</code>","text":"<p>Curried version of <code>chain</code> for <code>Either</code>. This allows chaining transformations on the Right value of <code>Either</code>, using a functional composition style.</p> <pre><code>import { Right, chain } from 'holo-fn/either';\n\nconst result = pipe(\n  new Right(5),\n  chain((x) =&gt; new Right(x + 5)),\n  (res) =&gt; res.unwrapOr(0)\n);\n\nconsole.log(result); // 10\n</code></pre>"},{"location":"either/#validate","title":"<code>validate</code>","text":"<p>Curried version of <code>validate</code> for <code>Either</code>. This allows filtering/validating values in a functional pipeline with custom error values.</p> <pre><code>import { right, validate, unwrapOr } from 'holo-fn/either';\n\nconst validateAge = (age: number) =&gt;\n  pipe(\n    right&lt;string, number&gt;(age),\n    validate((x: number) =&gt; x &gt;= 0, 'Age cannot be negative'),\n    validate((x: number) =&gt; x &lt;= 150, 'Age too high'),\n    validate((x: number) =&gt; x &gt;= 18, 'Must be 18+'),\n    unwrapOr(0)\n  );\n\nconsole.log(validateAge(25)); // 25\nconsole.log(validateAge(15)); // 0 (fails validation)\n</code></pre> <p>Common use cases:</p> <pre><code>import { right, tryCatch, validate } from 'holo-fn/either';\n\n// Validate email format\nconst validateEmail = (email: string) =&gt;\n  pipe(\n    right&lt;string, string&gt;(email),\n    validate((s: string) =&gt; s.length &gt; 0, 'Email is required'),\n    validate((s: string) =&gt; s.includes('@'), 'Must contain @'),\n    validate((s: string) =&gt; s.includes('.'), 'Invalid domain')\n  );\n\nconsole.log(validateEmail('test@example.com').unwrapOr('Invalid email'));\n\n// Parse and validate numbers\nconst parsePositive = (input: string) =&gt;\n  pipe(\n    tryCatch(\n      () =&gt; parseInt(input, 10),\n      () =&gt; 'Invalid number'\n    ),\n    validate((n: number) =&gt; !isNaN(n), 'Not a number'),\n    validate((n: number) =&gt; n &gt; 0, 'Must be positive')\n  );\n\nconsole.log(parsePositive('42').unwrapOr(0));\n\n// Validate with structured errors\ntype ValidationError = { code: string; message: string };\nconst validateUser = (age: number) =&gt;\n  pipe(\n    right&lt;ValidationError, number&gt;(age),\n    validate((x: number) =&gt; x &gt;= 18, { code: 'AGE_ERROR', message: 'Must be 18+' })\n  );\n\nconsole.log(validateUser(20));\nconsole.log(validateUser(15));\n</code></pre>"},{"location":"either/#unwrapor","title":"<code>unwrapOr</code>","text":"<p>Curried version of <code>unwrapOr</code> for <code>Either</code>. This provides a cleaner way to unwrap the value in a <code>Either</code>, returning a default value if it's <code>Left</code>.</p> <pre><code>import { Left, unwrapOr } from 'holo-fn/either';\n\nconst result = pipe(\n  new Left&lt;string, string&gt;(\"Fail\"),\n  unwrapOr(\"No value\")\n);\n\nconsole.log(result); // \"No value\"\n</code></pre>"},{"location":"either/#match","title":"<code>match</code>","text":"<p>Curried version of <code>match</code> for <code>Either</code>. This allows handling <code>Left</code> and <code>Right</code> in a functional way.</p> <pre><code>import { match, Right } from 'holo-fn/either';\n\nconst result = pipe(\n  new Right&lt;string, number&gt;(10),\n  match({\n    left: (e) =&gt; `Error: ${e}`,\n    right: (v) =&gt; `Success: ${v}`\n  })\n);\n\nconsole.log(result); // \"Success: 10\"\n</code></pre>"},{"location":"either/#equals","title":"<code>equals</code>","text":"<p>Curried version of <code>equals</code> for <code>Either</code>. Compares <code>this</code> to another <code>Either</code>, returns <code>false</code> if the values inside are different.</p> <pre><code>import { equals, Right } from 'holo-fn/either';\n\nconst result = pipe(\n  new Right(10),\n  equals(new Right(10))\n);\n\nconsole.log(result); // true\n</code></pre>"},{"location":"maybe/","title":"<code>Maybe&lt;T&gt;</code>","text":"<p><code>Maybe</code> is used to represent a value that may or may not exist. It can either be a <code>Just&lt;T&gt;</code> or a <code>Nothing</code>.</p> <pre><code>import { fromNullable } from 'holo-fn/maybe'\n\nconst name = fromNullable('Rich')\n  .map(n =&gt; n.toUpperCase())\n  .unwrapOr('Anonymous')\n\nconsole.log(name) // RICH\n</code></pre>"},{"location":"maybe/#methods","title":"Methods","text":""},{"location":"maybe/#mapfn-value-t-u-maybeu","title":"<code>map(fn: (value: T) =&gt; U): Maybe&lt;U&gt;</code>","text":"<p>Maps over the <code>Just</code> value. Does nothing for <code>Nothing</code>.</p> <pre><code>import { Just, Nothing } from \"holo-fn/maybe\";\n\nconst result1 = new Just(5).map((n) =&gt; n * 2);\nconsole.log(result1.unwrapOr(0)); // 10\n\nconst result2 = new Nothing&lt;number&gt;().map((n) =&gt; n * 2);\nconsole.log(result2.unwrapOr(0)); // 0\n</code></pre>"},{"location":"maybe/#chainfn-value-t-maybeu-maybeu","title":"<code>chain(fn: (value: T) =&gt; Maybe&lt;U&gt;): Maybe&lt;U&gt;</code>","text":"<p>Chains the transformation if the value is <code>Just</code>. Returns <code>Nothing</code> otherwise.</p> <pre><code>import { Just, Nothing } from \"holo-fn/maybe\";\n\nconst result1 = new Just(5).chain((n) =&gt; new Just(n * 2));\nconsole.log(result1.unwrapOr(0)); // 10\n\nconst result2 = new Nothing&lt;number&gt;().chain((n) =&gt; new Just(n * 2));\nconsole.log(result2.unwrapOr(0)); // 0\n</code></pre>"},{"location":"maybe/#filterfn-value-t-boolean-maybet","title":"<code>filter(fn: (value: T) =&gt; boolean): Maybe&lt;T&gt;</code>","text":"<p>Filters the <code>Just</code> value based on a predicate. If the predicate returns <code>true</code>, keeps the value. If it returns <code>false</code>, converts to <code>Nothing</code>. Does nothing for <code>Nothing</code>.</p> <pre><code>import { Just, Nothing } from \"holo-fn/maybe\";\n\nconst result1 = new Just(25).filter((n) =&gt; n &gt;= 18);\nconsole.log(result1.unwrapOr(0)); // 25\n\nconst result2 = new Just(15).filter((n) =&gt; n &gt;= 18);\nconsole.log(result2.unwrapOr(0)); // 0\n\nconst result3 = new Nothing&lt;number&gt;().filter((n) =&gt; n &gt;= 18);\nconsole.log(result3.unwrapOr(0)); // 0\n</code></pre>"},{"location":"maybe/#unwrapordefaultvalue-t-t","title":"<code>unwrapOr(defaultValue: T): T</code>","text":"<p>Returns the value of <code>Just</code>, or the default value for <code>Nothing</code>.</p> <pre><code>import { Just, Nothing } from \"holo-fn/maybe\";\n\nconst result1 = new Just(10);\nconsole.log(result1.unwrapOr(0)); // 10\n\nconst result2 = new Nothing&lt;number&gt;();\nconsole.log(result2.unwrapOr(0)); // 0\n</code></pre>"},{"location":"maybe/#isjust-boolean","title":"<code>isJust(): boolean</code>","text":"<p>Checks if the value is <code>Just</code>.</p> <pre><code>import { Just, Nothing } from \"holo-fn/maybe\";\n\nconst result1 = new Just(\"value\");\nconsole.log(result1.isJust()); // true\n\nconst result2 = new Nothing();\nconsole.log(result2.isJust()); // false\n</code></pre>"},{"location":"maybe/#isnothing-boolean","title":"<code>isNothing(): boolean</code>","text":"<p>Checks if the value is <code>Nothing</code>.</p> <pre><code>import { Just, Nothing } from \"holo-fn/maybe\";\n\nconst result1 = new Just(\"value\");\nconsole.log(result1.isNothing()); // false\n\nconst result2 = new Nothing();\nconsole.log(result2.isNothing()); // true\n</code></pre>"},{"location":"maybe/#matchucases-just-value-t-u-nothing-u-u","title":"<code>match&lt;U&gt;(cases: { just: (value: T) =&gt; U; nothing: () =&gt; U }): U</code>","text":"<p>Matches the value to execute either the <code>just</code> or <code>nothing</code> case.</p> <pre><code>import { Just, Nothing } from \"holo-fn/maybe\";\n\nconst result1 = new Just(\"value\").match({\n  just: (v) =&gt; `Has value: ${v}`,\n  nothing: () =&gt; \"No value\",\n});\nconsole.log(result1); // \"Has value: value\"\n\nconst result2 = new Nothing().match({\n  just: (v) =&gt; `Has value: ${v}`,\n  nothing: () =&gt; \"No value\",\n});\nconsole.log(result2); // \"No value\"\n</code></pre>"},{"location":"maybe/#equalsother-maybet-boolean","title":"<code>equals(other: Maybe&lt;T&gt;): boolean</code>","text":"<p>Compares the values inside <code>this</code> and the other, returns <code>true</code> if both are <code>Nothing</code> or if the values are equal.</p> <pre><code>import { Just, Nothing } from \"holo-fn/maybe\";\n\nconst result1 = new Just(\"value\").chain(v =&gt; new Just(v + \" modified\"));\n\nconsole.log(result1.equals(new Just(\"value\"))); // false\nconsole.log(result1.equals(new Just(\"value modified\"))); // true\n\nconst result2 = new Just(\"value\").chain(v =&gt; new Nothing());\nconsole.log(result2.equals(new Nothing())); // true\nconsole.log(result2.equals(new Just(\"value\"))); // false\n</code></pre>"},{"location":"maybe/#helpers","title":"Helpers","text":""},{"location":"maybe/#justvalue-t-maybet","title":"<code>just(value: T): Maybe&lt;T&gt;</code>","text":"<p>Creates a <code>Just</code> value with the given value, representing the presence of a value.</p> <pre><code>import { just } from 'holo-fn/maybe';\n\nconst maybeValue = just('Hello');\nconsole.log(maybeValue.unwrapOr('Default')); // 'Hello'\n</code></pre>"},{"location":"maybe/#nothingt-never-maybet","title":"<code>nothing&lt;T = never&gt;(): Maybe&lt;T&gt;</code>","text":"<p>Creates a <code>Nothing</code> value, representing the absence of a value.</p> <pre><code>import { nothing } from 'holo-fn/maybe';\n\nconst maybeValue = nothing&lt;string&gt;();\nconsole.log(maybeValue.unwrapOr('Default')); // 'Default'\n</code></pre>"},{"location":"maybe/#fromnullablevalue","title":"<code>fromNullable(value)</code>","text":"<p>Creates a <code>Maybe</code> from a value that might be <code>null</code> or <code>undefined</code>.</p> <pre><code>const maybeEmail = fromNullable(user.email)\n</code></pre> <ul> <li>Returns <code>Just&lt;T&gt;</code> if the value is not <code>null</code> or <code>undefined</code></li> <li>Returns <code>Nothing</code> otherwise</li> </ul>"},{"location":"maybe/#curried-helpers","title":"Curried Helpers","text":""},{"location":"maybe/#map","title":"<code>map</code>","text":"<p>Curried version of <code>map</code> for <code>Maybe</code>. This allows functional composition with <code>pipe</code>.</p> <pre><code>import { Just, map } from 'holo-fn/maybe';\n\nconst result = pipe(\n  new Just(10),\n  map((x) =&gt; x * 2),\n  (res) =&gt; res.unwrapOr(0)\n);\n\nconsole.log(result); // 20\n</code></pre>"},{"location":"maybe/#chain","title":"<code>chain</code>","text":"<p>Curried version of <code>chain</code> for <code>Maybe</code>. This allows chaining transformations in a functional pipeline.</p> <pre><code>import { chain, Just } from 'holo-fn/maybe';\n\nconst result = pipe(\n  new Just(2),\n  chain((x) =&gt; new Just(x * 10)),\n  (res) =&gt; res.unwrapOr(0)\n);\n\nconsole.log(result); // 20\n</code></pre>"},{"location":"maybe/#filter","title":"<code>filter</code>","text":"<p>Curried version of <code>filter</code> for <code>Maybe</code>. This allows filtering values in a functional pipeline based on a predicate.</p> <pre><code>import { filter, just, pipe } from 'holo-fn/maybe';\n\nconst result = pipe(\n  just(25),\n  filter((x) =&gt; x &gt;= 18),\n  filter((x) =&gt; x &lt;= 100),\n  (res) =&gt; res.unwrapOr(0)\n);\n\nconsole.log(result); // 25\n\n// Validate age\nconst validateAge = (age: number) =&gt;\n  pipe(\n    just(age),\n    filter((x) =&gt; x &gt;= 0),\n    filter((x) =&gt; x &lt;= 150),\n    filter((x) =&gt; x &gt;= 18)\n  );\n\nconsole.log(validateAge(151).unwrapOr(0)); // 25\n\n// Validate email format\nconst validateEmail = (email: string) =&gt;\n  pipe(\n    just(email),\n    filter((s) =&gt; s.length &gt; 0),\n    filter((s) =&gt; s.includes('@')),\n    filter((s) =&gt; s.split('@')[1]?.includes('.') ?? false)\n  );\n\nconsole.log(validateEmail('test@example.com').unwrapOr('Invalid email'));\n\n// Parse positive integers\nconst parsePositive = (input: string) =&gt;\n  pipe(\n    just(input),\n    map((s) =&gt; parseInt(s, 10)),\n    filter((n) =&gt; !isNaN(n)),\n    filter((n) =&gt; n &gt; 0)\n  );\n\nconsole.log(parsePositive('42').unwrapOr(0)); // 42\n</code></pre>"},{"location":"maybe/#unwrapor","title":"<code>unwrapOr</code>","text":"<p>Curried version of <code>unwrapOr</code> for <code>Maybe</code>. This provides a cleaner way to unwrap the value in a <code>Maybe</code>.</p> <pre><code>import { Nothing, unwrapOr } from 'holo-fn/maybe';\n\nconst result = pipe(\n  new Nothing&lt;string&gt;(),\n  unwrapOr(\"No value\")\n);\n\nconsole.log(result); // \"No value\"\n</code></pre>"},{"location":"maybe/#match","title":"<code>match</code>","text":"<p>Curried version of <code>match</code> for <code>Maybe</code>. This allows handling <code>Just</code> and <code>Nothing</code> in a functional way.</p> <pre><code>import { Just, match } from 'holo-fn/maybe';\n\nconst result = pipe(\n  new Just(\"hello\"),\n  match({\n    just: (v) =&gt; `Got ${v}`,\n    nothing: () =&gt; \"No value\"\n  })\n);\n\nconsole.log(result); // \"Got hello\"\n</code></pre>"},{"location":"maybe/#equals","title":"<code>equals</code>","text":"<p>Curried version of <code>equals</code> for <code>Maybe</code>. Compares the values inside <code>this</code> and the other, returns <code>true</code> if both are <code>Nothing</code> or if the values are equal.</p> <pre><code>import { equals, Just } from 'holo-fn/maybe';\n\nconst result = pipe(\n  new Just(10),\n  equals(new Just(10))\n);\n\nconsole.log(result); // true\n</code></pre>"},{"location":"result/","title":"<code>Result&lt;T, E&gt;</code>","text":"<p><code>Result</code> is used to represent computations that either succeed with a value (<code>Ok&lt;T&gt;</code>) or fail with an error (<code>Err&lt;E&gt;</code>).</p> <pre><code>import { Ok } from 'holo-fn/result'\n\nconst result = new Ok&lt;number, string&gt;(10)\n  .map(n =&gt; n + 1)\n  .unwrapOr(0)\n\nconsole.log(result) // 11\n</code></pre>"},{"location":"result/#methods","title":"Methods","text":""},{"location":"result/#mapfn-value-t-u-resultu-e","title":"<code>map(fn: (value: T) =&gt; U): Result&lt;U, E&gt;</code>","text":"<p>Maps over the <code>Ok</code> value. Does nothing for <code>Err</code>.</p> <pre><code>import { Ok, Err } from \"holo-fn/result\";\n\nconst result1 = new Ok(5).map((n) =&gt; n * 2);\nconsole.log(result1.unwrapOr(0)); // 10\n\nconst result2 = new Err&lt;number, string&gt;(\"Error\").map((n) =&gt; n * 2);\nconsole.log(result2.unwrapOr(0)); // 0\n</code></pre>"},{"location":"result/#maperrfn-err-e-f-resultt-f","title":"<code>mapErr(fn: (err: E) =&gt; F): Result&lt;T, F&gt;</code>","text":"<p>Maps over the <code>Err</code> value. Does nothing for <code>Ok</code>.</p> <pre><code>import { Ok, Err } from \"holo-fn/result\";\n\nconst result1 = new Ok(10).mapErr((e) =&gt; `Error: ${e}`);\nconsole.log(result1.unwrapOr(0)); // 10\n\nconst result2 = new Err(\"Fail\").mapErr((e) =&gt; `Mapped error: ${e}`);\nconsole.log(result2.unwrapOr(0)); // 0\n</code></pre>"},{"location":"result/#chainfn-value-t-resultu-e-resultu-e","title":"<code>chain(fn: (value: T) =&gt; Result&lt;U, E&gt;): Result&lt;U, E&gt;</code>","text":"<p>Chains the transformation if the value is <code>Ok</code>. Returns <code>Err</code> otherwise.</p> <pre><code>import { Ok, Err } from \"holo-fn/result\";\n\nconst result1 = new Ok(5)\n  .chain((n) =&gt; new Ok(n * 2))\n  .unwrapOr(0);\nconsole.log(result1); // 10\n\nconst result2 = new Err&lt;number, string&gt;(\"Error\")\n  .chain((n) =&gt; new Ok(n * 2))\n  .unwrapOr(0);\nconsole.log(result2); // 0\n</code></pre>"},{"location":"result/#validatepredicate-value-t-boolean-error-e-resultt-e","title":"<code>validate(predicate: (value: T) =&gt; boolean, error: E): Result&lt;T, E&gt;</code>","text":"<p>Validates the <code>Ok</code> value based on a predicate. If the predicate returns <code>true</code>, keeps the value. If it returns <code>false</code>, converts to <code>Err</code> with the provided error. Does nothing for <code>Err</code>.</p> <pre><code>import { Ok, Err } from \"holo-fn/result\";\n\nconst result1 = new Ok(25).validate((n) =&gt; n &gt;= 18, 'Must be 18+');\nconsole.log(result1.unwrapOr(0)); // 25\n\nconst result2 = new Ok(15).validate((n) =&gt; n &gt;= 18, 'Must be 18+');\nconsole.log(result2.isErr()); // true\n\nconst result3 = new Err&lt;number, string&gt;('Already failed').validate((n) =&gt; n &gt;= 18, 'Must be 18+');\nconsole.log(result3.isErr()); // true (keeps original error)\n</code></pre>"},{"location":"result/#unwrapordefaultvalue-t-t","title":"<code>unwrapOr(defaultValue: T): T</code>","text":"<p>Returns the value of <code>Ok</code>, or the default value for <code>Err</code>.</p> <pre><code>import { Ok, Err } from \"holo-fn/result\";\n\nconst result1 = new Ok(15).unwrapOr(0);\nconsole.log(result1); // 15\n\nconst result2 = new Err(\"Error\").unwrapOr(100);\nconsole.log(result2); // 100\n</code></pre>"},{"location":"result/#isok-boolean","title":"<code>isOk(): boolean</code>","text":"<p>Checks if the value is <code>Ok</code>.</p> <pre><code>import { Ok, Err } from \"holo-fn/result\";\n\nconst result1 = new Ok(5);\nconsole.log(result1.isOk()); // true\n\nconst result2 = new Err(\"Error\");\nconsole.log(result2.isOk()); // false\n</code></pre>"},{"location":"result/#iserr-boolean","title":"<code>isErr(): boolean</code>","text":"<p>Checks if the value is <code>Err</code>.</p> <pre><code>import { Ok, Err } from \"holo-fn/result\";\n\nconst result1 = new Ok(5);\nconsole.log(result1.isErr()); // false\n\nconst result2 = new Err(\"Error\");\nconsole.log(result2.isErr()); // true\n</code></pre>"},{"location":"result/#matchtcases-ok-value-t-t-err-err-e-t-t","title":"<code>match&lt;T&gt;(cases: { ok: (value: T) =&gt; T; err: (err: E) =&gt; T }): T</code>","text":"<p>Matches the value to execute either the <code>ok</code> or <code>err</code> case.</p> <pre><code>import { Ok, Err } from \"holo-fn/result\";\n\nconst result1 = new Ok(10).match({\n  ok: (n) =&gt; `Success: ${n}`,\n  err: (e) =&gt; `Failure: ${e}`,\n});\nconsole.log(result1); // \"Success: 10\"\n\nconst result2 = new Err(\"Error\").match({\n  ok: (n) =&gt; `Success: ${n}`,\n  err: (e) =&gt; `Failure: ${e}`,\n});\nconsole.log(result2); // \"Failure: Error\"\n</code></pre>"},{"location":"result/#equalsother-resultt-e-boolean","title":"<code>equals(other: Result&lt;T, E&gt;): boolean</code>","text":"<p>Compares <code>this</code> to another <code>Result</code>, returns <code>false</code> if the values inside are different.</p> <pre><code>import { Ok, Err } from \"holo-fn/result\";\n\nconst result1 = new Ok(10);\nconsole.log(result1.equals(new Ok(10))); // true\nconsole.log(result1.equals(new Ok(20))); // false\nconsole.log(result1.equals(new Err(\"Error\"))); // false\n\n\nconst result2 = new Err(\"Error\");\nconsole.log(result2.equals(new Err(\"Error\"))); // true\nconsole.log(result1.equals(new Err(\"Error\"))); // false\nconsole.log(result2.equals(new Ok(10))); // false\n</code></pre>"},{"location":"result/#helpers","title":"Helpers","text":""},{"location":"result/#okt-evalue-t-resultt-e","title":"<code>ok&lt;T, E&gt;(value: T): Result&lt;T, E&gt;</code>","text":"<p>Creates an <code>Ok</code> value, representing the success of an operation with a value.</p> <pre><code>import { ok } from 'holo-fn/result';\n\nconst resultValue = ok(10);\nconsole.log(resultValue.unwrapOr(0)); // 10\n</code></pre>"},{"location":"result/#errt-eerror-e-resultt-e","title":"<code>err&lt;T, E&gt;(error: E): Result&lt;T, E&gt;</code>","text":"<p>Creates an <code>Err</code> value, representing a failed operation with an value.</p> <pre><code>import { err } from 'holo-fn/result';\n\nconst resultValue = err(\"Error\");\nconsole.log(resultValue.unwrapOr(\"No error\")); // \"No error\"\n</code></pre>"},{"location":"result/#fromthrowablefn-onerror","title":"<code>fromThrowable(fn, onError?)</code>","text":"<p>Wraps a synchronous function in a <code>Result</code>.</p> <pre><code>import { fromThrowable } from 'holo-fn/result';\n\nconst input = '{\"name\": \"John\", \"age\": 30}'\n\nconst result = fromThrowable(() =&gt; JSON.parse(input), e =&gt; 'Invalid JSON')\n\nconsole.log(result) // _Ok { value: { name: 'John', age: 30 } }\n</code></pre> <ul> <li>Returns <code>Ok&lt;T&gt;</code> if <code>fn()</code> succeeds</li> <li>Returns <code>Err&lt;E&gt;</code> if it throws, using <code>onError</code> if provided</li> </ul>"},{"location":"result/#frompromisepromise-onerror","title":"<code>fromPromise(promise, onError?)</code>","text":"<p>Wraps a <code>Promise&lt;T&gt;</code> into a <code>Promise&lt;Result&lt;T, E&gt;&gt;</code>.</p> <pre><code>import { fromPromise } from 'holo-fn/result';\n\nconst result = await fromPromise(fetch('/api'), e =&gt; 'Network error')\n\nconsole.log(result) // _Err { error: 'Network error' }\n</code></pre> <ul> <li>Resolves to <code>Ok&lt;T&gt;</code> on success</li> <li>Resolves to <code>Err&lt;E&gt;</code> on failure</li> </ul>"},{"location":"result/#fromasyncfn-onerror","title":"<code>fromAsync(fn, onError?)</code>","text":"<p>Same as <code>fromPromise</code>, but lazy \u2014 receives a function returning a Promise.</p> <pre><code>import { fromAsync } from 'holo-fn/result';\n\nconst result = await fromAsync(() =&gt; fetch('/api'), e =&gt; 'Request failed')\n\nconsole.log(result) // _Err { error: 'Request failed' }\n</code></pre> <ul> <li>Allows deferred execution</li> <li>Handles exceptions from <code>async () =&gt; ...</code></li> </ul>"},{"location":"result/#curried-helpers","title":"Curried Helpers","text":""},{"location":"result/#map","title":"<code>map</code>","text":"<p>Curried version of the <code>map</code> function for <code>Result</code>. This allows you to apply a transformation to the Ok value in a more functional style.</p> <pre><code>import { map, Ok } from 'holo-fn/result';\n\nconst result = pipe(\n  new Ok(5),\n  map((x) =&gt; x * 2),\n  (res) =&gt; res.unwrapOr(0)\n);\n\nconsole.log(result); // 10\n</code></pre>"},{"location":"result/#maperr","title":"<code>mapErr</code>","text":"<p>Curried version of <code>mapErr</code> for <code>Result</code>. This allows handling errors in a more functional composition style.</p> <pre><code>import { Err, mapErr, Ok, Result } from 'holo-fn/result';\n\nconst getValue = (value: string | null): Result&lt;string, string&gt; =&gt; {\n    if (value === null) {\n        return new Err(\"Value is null\");\n    }\n    return new Ok(value);\n}\n\nconst result = pipe(\n  getValue(null),\n  mapErr((e) =&gt; `Mapped error: ${e}`),\n  (res) =&gt; res.unwrapOr(\"No value\")\n);\n\nconsole.log(result); // \"No value\"\n</code></pre>"},{"location":"result/#chain","title":"<code>chain</code>","text":"<p>Curried version of <code>chain</code> for <code>Result</code>. This allows you to chain transformations on the Ok value in a functional pipeline.</p> <pre><code>import { chain, Ok } from 'holo-fn/result';\n\nconst result = pipe(\n  new Ok(10),\n  chain((x) =&gt; new Ok(x + 5)),\n  (res) =&gt; res.unwrapOr(0)\n);\n\nconsole.log(result); // 15\n</code></pre>"},{"location":"result/#validate","title":"<code>validate</code>","text":"<p>Curried version of <code>validate</code> for <code>Result</code>. This allows filtering/validating values in a functional pipeline with custom error messages.</p> <pre><code>import { ok, validate, unwrapOr } from 'holo-fn/result';\n\nconst validateAge = (age: number) =&gt;\n  pipe(\n    ok&lt;number, string&gt;(age),\n    validate((x) =&gt; x &gt;= 0, 'Age cannot be negative'),\n    validate((x) =&gt; x &lt;= 150, 'Age too high'),\n    validate((x) =&gt; x &gt;= 18, 'Must be 18+'),\n    unwrapOr(0)\n  );\n\nconsole.log(validateAge(25)); // 25\nconsole.log(validateAge(15)); // 0 (fails validation)\n</code></pre> <p>Common use cases:</p> <pre><code>// Validate email format\nconst validateEmail = (email: string) =&gt;\n  pipe(\n    ok&lt;string, string&gt;(email),\n    validate((s) =&gt; s.length &gt; 0, 'Email is required'),\n    validate((s) =&gt; s.includes('@'), 'Must contain @'),\n    validate((s) =&gt; s.includes('.'), 'Invalid domain')\n  );\n\nconsole.log(validateEmail('test@example.com').unwrapOr('Invalid'));\n\n// Parse and validate numbers\nconst parsePositive = (input: string) =&gt;\n  pipe(\n    fromThrowable(\n      () =&gt; parseInt(input, 10),\n      () =&gt; 'Invalid number'\n    ),\n    validate((n) =&gt; !isNaN(n), 'Not a number'),\n    validate((n) =&gt; n &gt; 0, 'Must be positive')\n  );\n\nconsole.log(parsePositive('42').unwrapOr(0)); // 42\nconsole.log(parsePositive('-5').unwrapOr(0));\n\n// Validate objects\ntype User = { name: string; age: number };\nconst validateUser = (user: User) =&gt;\n  pipe(\n    ok&lt;User, string&gt;(user),\n    validate((u) =&gt; u.name.length &gt; 0, 'Name required'),\n    validate((u) =&gt; u.age &gt;= 18, 'Must be adult')\n  );\n\nconsole.log(validateUser({ name: 'Alice', age: 30 }).unwrapOr({ name: '', age: 0 }));\nconsole.log(validateUser({ name: '', age: 16 }).unwrapOr({ name: '', age: 0 }));\n</code></pre>"},{"location":"result/#unwrapor","title":"<code>unwrapOr</code>","text":"<p>Curried version of <code>unwrapOr</code> for <code>Result</code>. This provides a cleaner way to unwrap the value in a <code>Result</code>, returning a default value if it's <code>Err</code>.</p> <pre><code>import { Ok, unwrapOr } from 'holo-fn/result';\n\nconst result = pipe(\n  new Ok(42),\n  unwrapOr(0)\n);\n\nconsole.log(result); // 42\n</code></pre>"},{"location":"result/#match","title":"<code>match</code>","text":"<p>Curried version of <code>match</code> for <code>Result</code>. This allows you to handle both <code>Ok</code> and <code>Err</code> in a functional way, providing a clean way to handle both cases.</p> <pre><code>import { match, Ok } from 'holo-fn/result';\n\nconst result = pipe(\n  new Ok(10),\n  match({\n    ok: (v) =&gt; `Success: ${v}`,\n    err: (e) =&gt; `Error: ${e}`\n  })\n);\n\nconsole.log(result); // \"Success: 10\"\n</code></pre>"},{"location":"result/#equals","title":"<code>equals</code>","text":"<p>Curried version of <code>equals</code> for <code>Result</code>. Compares <code>this</code> to another <code>Result</code>, returns <code>false</code> if the values inside are different.</p> <pre><code>import { equals, Ok } from 'holo-fn/result';\n\nconst result1 = pipe(\n  new Ok(10),\n  equals(new Ok(10)),\n);\n\nconsole.log(result1); // true\n\nconst result2 = pipe(\n  new Ok(10),\n  equals(new Ok(11)),\n);\n\nconsole.log(result2); // false\n</code></pre>"}]}