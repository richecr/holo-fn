{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83d\udcda Holo-fn","text":"<p>A minimal functional library for TypeScript featuring monads like <code>Maybe</code>, <code>Either</code> and <code>Result</code>. Built for composability and Rambda compatibility.</p> <p>\ud83d\udca1 Designed to work seamlessly with <code>pipe</code> from Rambda. Fully typed, immutable, and safe by default.</p> <p>Below you will find detailed explanations, examples, and usage instructions to help you get started with holo-fn.</p>"},{"location":"#table-of-contents","title":"\u2728 Table of Contents","text":"<ul> <li>Introduction</li> <li>Features</li> <li>Getting Started</li> <li>API Reference<ul> <li>Maybe</li> <li>Either</li> <li>Result</li> <li>Helpers<ul> <li>tap - Side-effects in pipelines</li> <li>inspect - Debug logging with labels</li> </ul> </li> </ul> </li> <li>Contributing</li> <li>Changelog</li> </ul>"},{"location":"#introduction","title":"\ud83d\udca1 Introduction","text":"<p>holo-fn is a minimal functional library designed for TypeScript with full support for monads and functional programming principles. It includes commonly used monads like <code>Maybe</code>, <code>Either</code>, and <code>Result</code> for safe and composable functional programming.</p> <ul> <li>Designed to work seamlessly with <code>pipe</code> from <code>Rambda</code>.</li> <li>Fully typed, immutable by default, and safe for modern TypeScript development.</li> </ul>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\u2705 Functional types: <code>Maybe</code>, <code>Either</code>, <code>Result</code></li> <li>\u2699\ufe0f Pipe-friendly (Rambda/Ramda compatible)</li> <li>\ud83d\udd12 Immutable by default</li> <li>\ud83e\uddea 100% test coverage</li> <li>\u26a1\ufe0f Zero dependencies</li> <li>\ud83e\udde0 Full TypeScript inference</li> </ul>"},{"location":"_future_features/","title":"Futuras Features para holo-fn","text":"<p>Este documento cont\u00e9m ideias de novas funcionalidades para a biblioteca holo-fn.</p>"},{"location":"_future_features/#1-validacao-e-parsing","title":"1. Valida\u00e7\u00e3o e Parsing","text":"<p><pre><code>validate&lt;T&gt;(predicate: (value: T) =&gt; boolean): Maybe&lt;T&gt;\nfilter&lt;T&gt;(predicate: (value: T) =&gt; boolean): Maybe&lt;T&gt;\nvalidateWith&lt;T, E&gt;(value: T, predicate: (v: T) =&gt; boolean, error: E): Either&lt;E, T&gt;\n</code></pre> \u00datil para valida\u00e7\u00f5es de dados de formul\u00e1rios, APIs, etc.</p>"},{"location":"_future_features/#2-combinadoresagregadores","title":"2. Combinadores/Agregadores","text":"<p><pre><code>all&lt;T&gt;(maybes: Maybe&lt;T&gt;[]): Maybe&lt;T[]&gt;\nany&lt;T&gt;(maybes: Maybe&lt;T&gt;[]): Maybe&lt;T&gt;\nsequence&lt;T&gt;(maybes: Maybe&lt;T&gt;[]): Maybe&lt;T[]&gt;\ntraverse&lt;T, U&gt;(fn: (x: T) =&gt; Maybe&lt;U&gt;, arr: T[]): Maybe&lt;U[]&gt;\npartition&lt;L, R&gt;(eithers: Either&lt;L, R&gt;[]): { lefts: L[], rights: R[] }\n</code></pre> Essencial para trabalhar com listas de opera\u00e7\u00f5es que podem falhar.</p>"},{"location":"_future_features/#3-conversoes-entre-tipos","title":"3. Convers\u00f5es entre tipos","text":"<p><pre><code>maybeToEither&lt;L, R&gt;(maybe: Maybe&lt;R&gt;, leftValue: L): Either&lt;L, R&gt;\nmaybeToResult&lt;T, E&gt;(maybe: Maybe&lt;T&gt;, error: E): Result&lt;T, E&gt;\neitherToResult&lt;T, E&gt;(either: Either&lt;E, T&gt;): Result&lt;T, E&gt;\nresultToEither&lt;T, E&gt;(result: Result&lt;T, E&gt;): Either&lt;E, T&gt;\n</code></pre> Facilita a interoperabilidade entre os tr\u00eas tipos de monads.</p>"},{"location":"_future_features/#4-utilitarios-async-avancados","title":"4. Utilit\u00e1rios Async Avan\u00e7ados","text":"<pre><code>retryWithBackoff&lt;T, E&gt;(fn: () =&gt; Promise&lt;T&gt;, options: { maxRetries: number, delayMs: number }): Promise&lt;Result&lt;T, E&gt;&gt;\nwithTimeout&lt;T, E&gt;(promise: Promise&lt;T&gt;, timeoutMs: number, error: E): Promise&lt;Result&lt;T, E&gt;&gt;\nallSettled&lt;T, E&gt;(promises: Promise&lt;T&gt;[]): Promise&lt;Result&lt;T, E&gt;[]&gt;\n</code></pre>"},{"location":"_future_features/#5-pattern-matching-estendido","title":"5. Pattern Matching Estendido","text":"<pre><code>matchMany([maybe1, maybe2], { allJust: (v1, v2) =&gt; ..., someNothing: () =&gt; ... })\nmatchWith(value, [[predicate1, handler1], [predicate2, handler2], [() =&gt; true, defaultHandler]])\n</code></pre>"},{"location":"_future_features/#6-debuglogging-helpers","title":"6. Debug/Logging Helpers","text":"<p><pre><code>tap&lt;T&gt;(fn: (value: T) =&gt; void): (maybe: Maybe&lt;T&gt;) =&gt; Maybe&lt;T&gt;\ninspect&lt;T&gt;(label?: string): (maybe: Maybe&lt;T&gt;) =&gt; Maybe&lt;T&gt;\n</code></pre> Para facilitar debugging em pipelines funcionais.</p>"},{"location":"_future_features/#7-utilitarios-para-objetos","title":"7. Utilit\u00e1rios para Objetos","text":"<pre><code>mapProps&lt;T extends object, K extends keyof T&gt;(obj: T, key: K, fn: (v: T[K]) =&gt; T[K]): Maybe&lt;T&gt;\ngetPath&lt;T&gt;(obj: unknown, path: string[]): Maybe&lt;T&gt;\n</code></pre>"},{"location":"_future_features/#8-monoidsemigroup-support","title":"8. Monoid/Semigroup Support","text":"<pre><code>combine&lt;T&gt;(maybe1: Maybe&lt;T&gt;, maybe2: Maybe&lt;T&gt;, combiner: (a: T, b: T) =&gt; T): Maybe&lt;T&gt;\nconcat&lt;T&gt;(maybes: Maybe&lt;T&gt;[]): Maybe&lt;T&gt;\n</code></pre>"},{"location":"_future_features/#9-lazy-evaluation","title":"9. Lazy Evaluation","text":"<pre><code>lazy&lt;T&gt;(thunk: () =&gt; Maybe&lt;T&gt;): LazyMaybe&lt;T&gt;\n</code></pre>"},{"location":"_future_features/#10-json-serialization","title":"10. JSON Serialization","text":"<pre><code>toJSON&lt;T&gt;(maybe: Maybe&lt;T&gt;): { type: 'Just' | 'Nothing', value?: T }\nfromJSON&lt;T&gt;(json: any): Maybe&lt;T&gt;\n</code></pre>"},{"location":"_future_features/#prioridades","title":"Prioridades","text":"<ol> <li>Combinadores (all/sequence) - Muito comum trabalhar com listas de opera\u00e7\u00f5es</li> <li>Convers\u00f5es entre tipos - Aumenta a flexibilidade da biblioteca</li> <li>Valida\u00e7\u00e3o/Filter - Caso de uso extremamente comum</li> </ol>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#120-2025-12-08","title":"1.2.0 - 2025-12-08","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li> <p><code>tap</code> helper function: Executes side-effects in functional pipelines without altering data flow.</p> <ul> <li>Generic utility that works with any type (monads, primitives, objects, arrays).</li> <li>Useful for debugging, logging, metrics, and error tracking.</li> <li>Example: <pre><code>pipe(\n  just(42),\n  tap(x =&gt; console.log('Value:', x)),\n  map(x =&gt; x * 2)\n);\n</code></pre></li> </ul> </li> <li> <p><code>inspect</code> helper function: Logs values with optional labels for debugging.</p> <ul> <li>Specialized version of <code>tap</code> that automatically uses <code>console.log</code>.</li> <li>Convenient for quick debugging with optional label prefixes.</li> <li>Example: <pre><code>pipe(\n  just(42),\n  inspect('After init'),  // Logs: \"After init: Just(42)\"\n  map(x =&gt; x * 2),\n  inspect('Final result')\n);\n</code></pre></li> </ul> </li> <li> <p><code>all</code> combinator for <code>Maybe</code>, <code>Result</code>, and <code>Either</code>: Combines an array of monads into a single monad containing an array of values.</p> <ul> <li><code>Maybe</code>: Returns <code>Just</code> with all values if all are <code>Just</code>, or <code>Nothing</code> if any is <code>Nothing</code>.</li> <li><code>Result</code>/<code>Either</code>: Collects all errors if any fail.</li> <li>Heterogeneous tuple support: Preserves different types in arrays using advanced TypeScript type inference.</li> <li>Example: <pre><code>all([just(1), just(2), just(3)]).unwrapOr([]); // [1, 2, 3]\nall([ok(1), err('e1'), err('e2')]); // Err(['e1', 'e2'])\nall([just(42), just(\"hello\"), just(true)]); // Just&lt;[number, string, boolean]&gt;\n</code></pre></li> </ul> </li> <li> <p><code>sequence</code> combinator for <code>Result</code> and <code>Either</code>: Combines an array of monads with fail-fast behavior.</p> <ul> <li>Stops at the first error instead of collecting all errors.</li> <li>Returns single error type instead of array.</li> <li>Heterogeneous tuple support: Preserves different types in arrays.</li> <li>Example: <pre><code>sequence([ok(1), err('e1'), err('e2')]); // Err('e1') - stops at first!\n</code></pre></li> </ul> </li> <li> <p><code>partition</code> function for <code>Result</code> and <code>Either</code>: Separates an array of monads into successes and failures.</p> <ul> <li>Returns a plain object with two arrays (not a monad).</li> <li>Always processes all items.</li> <li>Heterogeneous tuple support: Preserves different types in returned arrays.</li> <li>Example: <pre><code>partition([ok(1), err('e1'), ok(2), err('e2')]);\n// { oks: [1, 2], errs: ['e1', 'e2'] }\n</code></pre></li> </ul> </li> <li> <p>Common Patterns documentation: Added comprehensive documentation section with practical recipes for:</p> <ul> <li>Validation pipelines with multiple checks</li> <li>Form validation with error collection</li> <li>Concurrent operations handling</li> <li>Async error handling patterns</li> <li>Data transformation pipelines</li> </ul> </li> </ul>"},{"location":"changelog/#110-2025-11-30","title":"[1.1.0] - 2025-11-30","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li> <p><code>filter</code> method for <code>Maybe</code>: Validates values with a predicate, converting <code>Just</code> to <code>Nothing</code> when the predicate fails.</p> <ul> <li>Added <code>filter(predicate: (value: T) =&gt; boolean): Maybe&lt;T&gt;</code> method to <code>Maybe</code> interface.</li> <li>Added curried <code>filter</code> function for use with <code>pipe</code>.</li> <li>Example: <pre><code>just(25).filter(x =&gt; x &gt;= 18).unwrapOr(0); // 25\njust(15).filter(x =&gt; x &gt;= 18).unwrapOr(0); // 0\n</code></pre></li> </ul> </li> <li> <p><code>validate</code> method for <code>Result</code> and <code>Either</code>: Validates values with custom error messages.</p> <ul> <li>Added <code>validate(predicate: (value: T) =&gt; boolean, error: E): Result&lt;T, E&gt;</code> to <code>Result</code>.</li> <li>Added <code>validate(predicate: (value: R) =&gt; boolean, leftValue: L): Either&lt;L, R&gt;</code> to <code>Either</code>.</li> <li>Added curried <code>validate</code> functions for use with <code>pipe</code>.</li> <li>Example: <pre><code>ok(25).validate(x =&gt; x &gt;= 18, 'Must be 18+').unwrapOr(0); // 25\nok(15).validate(x =&gt; x &gt;= 18, 'Must be 18+').isErr(); // true\n</code></pre></li> </ul> </li> </ul>"},{"location":"changelog/#100-2025-06-25","title":"[1.0.0] - 2025-06-25","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>First stable release of <code>holo-fn</code> with core monads: <code>Maybe</code>, <code>Either</code>, and <code>Result</code>.</li> <li><code>Maybe</code> monad:<ul> <li><code>Just</code>, <code>Nothing</code>, and helper functions like <code>fromNullable</code>.</li> <li>Added methods like <code>map</code>, <code>chain</code>, <code>unwrapOr</code>, <code>match</code>, and <code>equals</code>.</li> </ul> </li> <li><code>Either</code> monad:<ul> <li><code>Left</code>, 'Right', and helper functions like <code>tryCatch</code>, <code>fromPromise</code>, <code>fromAsync</code>.</li> <li>Added methods like <code>map</code>, <code>chain</code>, <code>unwrapOr</code>, <code>match</code>, and <code>equals</code>.</li> </ul> </li> <li><code>Result</code> monad:<ul> <li><code>Ok</code>, <code>Err</code>, and helper functions like <code>fromThrowable</code>, <code>fromPromise</code>, <code>fromAsync</code>.</li> <li>Added methods like <code>map</code>, <code>chain</code>, <code>unwrapOr</code>, <code>match</code>, and <code>equals</code>.</li> </ul> </li> <li>Introduced <code>curried functions</code> for <code>map</code>, <code>chain</code>, <code>unwrapOr</code>, and <code>match</code> for each monad:<ul> <li><code>map</code>, <code>chain</code>, <code>unwrapOr</code>, and <code>match</code> for <code>Either</code>, <code>Maybe</code> and <code>Result</code>.</li> </ul> </li> <li><code>Export restructuring</code>:<ul> <li>Now, monads are imported from their specific files, instead of a global import.</li> <li>Example: <pre><code>import { M, E, R } from \"holo-fn\";\nimport { fromNullable } from 'holo-fn/maybe';\nimport { tryCatch } from 'holo-fn/either';\nimport { fromThrowable } from 'holo-fn/result';\n</code></pre></li> </ul> </li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li><code>Migration to Bun</code>: The library is now compatible with <code>Bun</code> runtime, offering better performance and faster execution.</li> <li>Reorganized the imports for better modularization and performance.<ul> <li>Now, to use specific monads and functions, you must import from their respective files.</li> </ul> </li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fixed <code>bug</code> related to circular imports.</li> <li>Optimized the library for faster loading and reduced bundle size.</li> </ul>"},{"location":"changelog/#030-2025-05-10","title":"[0.3.0] - 2025-05-10","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>New helpers functions:<ul> <li>Maybe:<ul> <li>just(value: T): Maybe: Creates a <code>Just</code> value representing the presence of a value. <li>nothing(): Maybe: Creates a <code>Nothing</code> value representing the absence of a value. <li>Either:<ul> <li>left(value: L): Either: Creates a <code>Left</code> value representing a failure or error. <li>right(value: R): Either: Creates a <code>Right</code> value representing a success. <li>Result:<ul> <li>ok(value: T): Result: Creates an <code>Ok</code> value representing the success of an operation with a value. <li>err(error: E): Result: Creates an <code>Err</code> value representing a failure of an operation with an error."},{"location":"changelog/#020-2025-04-26","title":"[0.2.0] - 2025-04-26","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Introduced the <code>equals</code> method for Maybe, Either, and Result types to compare instances of these types based on their internal values.</li> <li>Added curried functions for <code>equals</code> to allow for easier composition and usage:<ul> <li><code>equalsM</code> for Maybe.</li> <li><code>equalsE</code> for Either.</li> <li><code>equalsR</code> for Result.</li> </ul> </li> <li>New helper functions for easy comparison between monadic values.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Refined the API for better type inference and consistency across all functional types (<code>Maybe</code>, <code>Either</code>, <code>Result</code>).</li> <li>Improved type safety for curried functions in all monads.</li> </ul>"},{"location":"changelog/#010-2025-04-23","title":"[0.1.0] - 2025-04-23","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Initial release of holo-fn with core monads: <code>Maybe</code>, <code>Either</code>, and <code>Result</code>.</li> <li><code>Maybe</code> monad: <code>Just</code>, <code>Nothing</code>, and helper functions like <code>fromNullable</code>.</li> <li><code>Either</code> monad: <code>Left</code>, <code>Right</code>, <code>tryCatch</code>, <code>fromPromise</code>, <code>fromAsync</code>.</li> <li><code>Result</code> monad: <code>Ok</code>, <code>Err</code>, <code>fromThrowable</code>, <code>fromPromise</code>, <code>fromAsync</code>.</li> <li>Added curried handlers for <code>map</code>, <code>chain</code>, <code>unwrapOr</code>, and <code>match</code> for better composition and functional pipelines:<ul> <li><code>mapE</code>, <code>chainE</code>, <code>unwrapOrE</code>, and <code>matchE</code> for <code>Either</code>.</li> <li><code>mapM</code>, <code>chainM</code>, <code>unwrapOrM</code>, and <code>matchM</code> for <code>Maybe</code>.</li> <li><code>mapR</code>, <code>chainR</code>, <code>unwrapOrR</code>, and <code>matchR</code> for <code>Result</code>.</li> </ul> </li> </ul>"},{"location":"contributing/","title":"Contributing to holo-fn","text":"<p>Thank you for your interest in contributing to holo-fn! To keep things organized and make it easier for you to get involved, please read through the guidelines below.</p>"},{"location":"contributing/#setup","title":"\ud83d\ude80 Setup","text":""},{"location":"contributing/#1-install-dependencies","title":"1. Install Dependencies","text":"<p>To get started, clone the repository and install the dependencies:</p> <pre><code>git clone https://github.com/yourusername/holo-fn.git\ncd holo-fn\nbun install\n</code></pre>"},{"location":"contributing/#2-running-tests-and-coverage","title":"2. Running Tests and Coverage","text":"<p>You can run the tests using Jest to ensure everything works as expected:</p> <pre><code>bun run test\n</code></pre> <p>To convert the coverage into an HTML report, run:</p> <pre><code>bun run coverage:html\n</code></pre>"},{"location":"contributing/#building","title":"\ud83d\udce6 Building","text":"<p>To build the project:</p> <pre><code>bun run build\n</code></pre>"},{"location":"contributing/#testing-locally","title":"\ud83e\uddf0 Testing Locally","text":"<p>To test your changes locally before publishing or linking the library:</p> <ol> <li> <p>Build the Library:</p> </li> <li> <p>Run the following to build the project and prepare the files for testing:   <pre><code>bun run build\n</code></pre></p> </li> <li> <p>Pack the Library:</p> </li> <li> <p>After building, run npm pack to create a .tgz file that you can install locally:   <pre><code>bun pm pack\n</code></pre></p> </li> <li> <p>Install Locally in Your Test Project:</p> </li> <li> <p>In the project where you want to test the library, run the following:   <pre><code>npm install /path/to/holo-fn-&lt;version&gt;.tgz\n</code></pre></p> </li> <li> <p>This will install the library locally in your project, and you can import and use it as if it were an npm package.</p> </li> </ol>"},{"location":"contributing/#how-to-contribute","title":"\ud83e\udd1d How to Contribute","text":"<ol> <li>Fork the repository to your GitHub account and clone it locally.</li> <li>Create a new branch for your feature or fix:    <pre><code>git checkout -b feat/issue-number-or-short-description\n</code></pre></li> <li>Make your changes: add your feature or fix the bug.</li> <li>Commit your changes:    <pre><code>git commit -am 'feat: add new feature'  # or 'fix: resolve issue'\n</code></pre></li> <li>Push to your fork:    <pre><code>git push origin feat/issue-number-or-short-description\n</code></pre></li> <li>Create a pull request from your fork to the main repository.</li> </ol>"},{"location":"contributing/#guidelines","title":"\ud83c\udfaf Guidelines","text":"<ul> <li>Please write clear commit messages.</li> <li>Ensure all code is properly tested.</li> <li>Follow the code style used in the project.</li> </ul> <p>Thank you for contributing! \ud83d\ude80</p>"},{"location":"getting_started/","title":"\ud83d\ude80 Getting Started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>To install holo-fn in your project, use the following npm command:</p> <pre><code>npm install holo-fn\n</code></pre>"},{"location":"getting_started/#importing","title":"Importing","text":"<p>You can import specific monads or helpers as needed:</p> <pre><code>import { M, E, R } from \"holo-fn\"\nimport { fromNullable } from 'holo-fn/maybe'\nimport { tryCatch } from 'holo-fn/either'\nimport { fromThrowable } from 'holo-fn/result'\n</code></pre>"},{"location":"getting_started/#api-reference","title":"\ud83d\udce6 API Reference","text":""},{"location":"getting_started/#core-monads","title":"Core Monads","text":"<ul> <li>Maybe - Optional values</li> <li>Either - Success or failure with values</li> <li>Result - Result with error handling</li> </ul>"},{"location":"getting_started/#helpers","title":"Helpers","text":"<ul> <li>tap - Execute side-effects in pipelines without altering data flow</li> <li>inspect - Debug logging with optional labels</li> </ul>"},{"location":"getting_started/#comparison-between-maybe-either-and-result","title":"\ud83d\udcda Comparison between Maybe, Either, and Result","text":"Aspect Maybe Either Result Purpose Represents a value that may be <code>null</code> or <code>undefined</code>. Represents an operation that can either succeed (<code>Right</code>) or fail (<code>Left</code>). Represents the result of an operation, which can either succeed (<code>Ok</code>) or fail with an error (<code>Err</code>). Types <code>Just&lt;T&gt;</code>, <code>Nothing</code> <code>Right&lt;R&gt;</code>, <code>Left&lt;L&gt;</code> <code>Ok&lt;T&gt;</code>, <code>Err&lt;E&gt;</code> Composition (map, chain) Supports <code>map</code>, <code>chain</code> for simple compositions. Supports <code>map</code>, <code>chain</code> for compositions involving success or failure. Supports <code>map</code>, <code>chain</code> for manipulating values or errors. Method to Access Value <code>getOrElse(defaultValue)</code> <code>getOrElse(defaultValue)</code> <code>unwrapOr(defaultValue)</code> Method for Success Case <code>isJust()</code>, <code>isNothing()</code> <code>isRight()</code>, <code>isLeft()</code> <code>isOk()</code>, <code>isErr()</code> Usage Example <code>fromNullable(value)</code> <code>new Right(value)</code> or <code>new Left(error)</code> <code>new Ok(value)</code> or <code>new Err(error)</code> When to Use When there is an optional value that may be <code>null</code> or <code>undefined</code>. When an operation can succeed or fail, and it is important to distinguish between them. When you need to clearly distinguish between success or failure in an operation. Common Helpers <code>fromNullable</code> <code>tryCatch</code>, <code>fromPromise</code> <code>fromThrowable</code>, <code>fromPromise</code>, <code>fromAsync</code> Example of <code>map</code> <code>maybeValue.map(value =&gt; value * 2)</code> <code>eitherValue.map(value =&gt; value * 2)</code> <code>resultValue.map(value =&gt; value * 2)</code> Example of <code>chain</code> <code>maybeValue.chain(value =&gt; fromNullable(value))</code> <code>eitherValue.chain(value =&gt; new Right(value))</code> <code>resultValue.chain(value =&gt; new Ok(value))</code>"},{"location":"getting_started/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in here.</p>"},{"location":"getting_started/#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions to holo-fn! Please refer to the CONTRIBUTING.md for detailed instructions on how to run tests, build the library, and contribute.</p>"},{"location":"getting_started/#license","title":"\ud83d\udcdc License","text":"<p>MIT</p>"},{"location":"tap/","title":"tap","text":"<p>A utility function for executing side-effects in functional pipelines without altering the data flow.</p>"},{"location":"tap/#overview","title":"Overview","text":"<p><code>tap</code> allows you to perform side-effects (like logging, debugging, or metrics) in the middle of a pipeline while keeping the data unchanged. It's a generic function that works with any value type - monads, arrays, objects, primitives, etc.</p>"},{"location":"tap/#signature","title":"Signature","text":"<pre><code>function tap&lt;T&gt;(fn: (value: T) =&gt; void): (value: T) =&gt; T\n</code></pre>"},{"location":"tap/#parameters","title":"Parameters","text":"<ul> <li><code>fn</code>: A function that receives the value and performs a side-effect (returns void)</li> </ul>"},{"location":"tap/#returns","title":"Returns","text":"<p>A function that: 1. Takes a value of type <code>T</code> 2. Executes the side-effect function with that value 3. Returns the original value unchanged</p>"},{"location":"tap/#usage","title":"Usage","text":""},{"location":"tap/#with-maybe","title":"With Maybe","text":"<pre><code>import { just, map, tap } from \"holo-fn\";\nimport { pipe } from \"rambda\";\n\nconst result = pipe(\n  just(42),\n  tap(m =&gt; console.log(\"Maybe:\", m.unwrapOr(0))),\n  map(x =&gt; x * 2),\n  tap(m =&gt; console.log(\"After map:\", m.unwrapOr(0)))\n);\n// Logs: \"Maybe: 42\"\n// Logs: \"After map: 84\"\n// Returns: Just(84)\n</code></pre>"},{"location":"tap/#with-result","title":"With Result","text":"<pre><code>import { ok, map, tap } from \"holo-fn\";\nimport { pipe } from \"rambda\";\n\nconst result = pipe(\n  ok(100),\n  tap(r =&gt; console.log(\"Initial:\", r.unwrapOr(0))),\n  map(x =&gt; x / 2),\n  tap(r =&gt; console.log(\"After division:\", r.unwrapOr(0)))\n);\n// Logs: \"Initial: 100\"\n// Logs: \"After division: 50\"\n// Returns: Ok(50)\n</code></pre>"},{"location":"tap/#with-either","title":"With Either","text":"<pre><code>import { right, map, tap } from \"holo-fn\";\nimport { pipe } from \"rambda\";\n\nconst result = pipe(\n  right(10),\n  tap(e =&gt; console.log(\"Right value:\", e.unwrapOr(0))),\n  map(x =&gt; x + 5),\n  tap(e =&gt; console.log(\"After adding:\", e.unwrapOr(0)))\n);\n// Logs: \"Right value: 10\"\n// Logs: \"After adding: 15\"\n// Returns: Right(15)\n</code></pre>"},{"location":"tap/#with-plain-values","title":"With Plain Values","text":"<pre><code>import { tap } from \"holo-fn\";\nimport { pipe } from \"rambda\";\n\nconst result = pipe(\n  42,\n  tap(x =&gt; console.log(\"Initial:\", x)),\n  x =&gt; x * 2,\n  tap(x =&gt; console.log(\"Doubled:\", x)),\n  x =&gt; x + 10,\n  tap(x =&gt; console.log(\"Final:\", x))\n);\n// Logs: \"Initial: 42\"\n// Logs: \"Doubled: 84\"\n// Logs: \"Final: 94\"\n// Returns: 94\n</code></pre>"},{"location":"tap/#with-arrays","title":"With Arrays","text":"<pre><code>import { tap } from \"holo-fn\";\nimport { pipe } from \"rambda\";\n\nconst result = pipe(\n  [1, 2, 3],\n  tap(arr =&gt; console.log(\"Length:\", arr.length)),\n  arr =&gt; arr.map(x =&gt; x * 2),\n  tap(arr =&gt; console.log(\"After map:\", arr)),\n  arr =&gt; arr.filter(x =&gt; x &gt; 2)\n);\n// Logs: \"Length: 3\"\n// Logs: \"After map: [2, 4, 6]\"\n// Returns: [4, 6]\n</code></pre>"},{"location":"tap/#with-objects","title":"With Objects","text":"<pre><code>import { tap } from \"holo-fn\";\nimport { pipe } from \"rambda\";\n\nconst result = pipe(\n  { name: \"Alice\", age: 25 },\n  tap(obj =&gt; console.log(\"User:\", obj.name)),\n  obj =&gt; ({ ...obj, age: obj.age + 1 }),\n  tap(obj =&gt; console.log(\"Age updated:\", obj.age))\n);\n// Logs: \"User: Alice\"\n// Logs: \"Age updated: 26\"\n// Returns: { name: \"Alice\", age: 26 }\n</code></pre>"},{"location":"tap/#common-use-cases","title":"Common Use Cases","text":""},{"location":"tap/#1-debugging","title":"1. Debugging","text":"<pre><code>const processData = pipe(\n  fetchData(),\n  tap(data =&gt; console.log(\"Raw data:\", data)),\n  parseData,\n  tap(parsed =&gt; console.log(\"Parsed:\", parsed)),\n  validateData,\n  tap(valid =&gt; console.log(\"Validated:\", valid))\n);\n</code></pre>"},{"location":"tap/#2-logging","title":"2. Logging","text":"<pre><code>const processUser = pipe(\n  getUser(id),\n  tap(user =&gt; logger.info(\"User fetched\", { userId: user.id })),\n  validateUser,\n  tap(user =&gt; logger.info(\"User validated\")),\n  saveUser,\n  tap(user =&gt; logger.info(\"User saved\", { userId: user.id }))\n);\n</code></pre>"},{"location":"tap/#3-metrics-and-monitoring","title":"3. Metrics and Monitoring","text":"<pre><code>const processOrder = pipe(\n  createOrder(data),\n  tap(order =&gt; metrics.recordOrderCreated(order.id)),\n  validateOrder,\n  tap(order =&gt; metrics.recordOrderValidated()),\n  processPayment,\n  tap(order =&gt; metrics.recordPaymentProcessed())\n);\n</code></pre>"},{"location":"tap/#4-side-effects-with-conditions","title":"4. Side-effects with Conditions","text":"<pre><code>const processValue = pipe(\n  getValue(),\n  tap(v =&gt; {\n    if (v &gt; 100) {\n      console.warn(\"High value detected:\", v);\n    }\n  }),\n  transform,\n  tap(v =&gt; {\n    if (debug.enabled) {\n      console.log(\"Debug:\", v);\n    }\n  })\n);\n</code></pre>"},{"location":"tap/#5-error-tracking","title":"5. Error Tracking","text":"<pre><code>const processData = pipe(\n  fetchData(),\n  tap(result =&gt; {\n    if (result.isErr()) {\n      sentry.captureException(result.extract());\n    }\n  }),\n  map(processValue),\n  tap(result =&gt; {\n    if (result.isErr()) {\n      logger.error(\"Processing failed\", result.extract());\n    }\n  })\n);\n</code></pre>"},{"location":"tap/#key-features","title":"Key Features","text":"<ul> <li>Generic: Works with any type - monads, primitives, objects, arrays</li> <li>Non-intrusive: Doesn't modify the data flowing through the pipeline</li> <li>Composable: Can be used multiple times in a single pipeline</li> <li>Type-safe: TypeScript preserves types correctly</li> <li>Flexible: Suitable for logging, debugging, metrics, or any side-effect</li> </ul>"},{"location":"tap/#tips","title":"Tips","text":"<ol> <li>Keep side-effects pure from data perspective: <code>tap</code> should not modify the value, only observe or perform external actions</li> <li>Use for observability: Great for adding logging/metrics without cluttering business logic</li> <li>Conditional logging: Wrap debug logs in conditions to avoid performance impact in production</li> <li>Chain multiple taps: Don't hesitate to use multiple <code>tap</code> calls for different concerns</li> </ol>"},{"location":"tap/#type-safety","title":"Type Safety","text":"<p>TypeScript correctly infers the type through <code>tap</code>:</p> <pre><code>// Type is preserved\nconst result: Maybe&lt;number&gt; = pipe(\n  just(42),\n  tap(x =&gt; console.log(x)), // x: Maybe&lt;number&gt;\n  map(x =&gt; x * 2)            // Type: Maybe&lt;number&gt;\n);\n\n// Works with union types\nconst value: string | number = pipe(\n  getUnionValue(),\n  tap(x =&gt; console.log(typeof x)), // x: string | number\n  transform\n);\n</code></pre>"},{"location":"tap/#related","title":"Related","text":"<ul> <li><code>map</code> - Transform values</li> <li><code>chain</code> - Chain computations</li> <li><code>match</code> - Pattern matching</li> </ul>"},{"location":"tap/#notes","title":"Notes","text":"<ul> <li>Side-effects in <code>fn</code> should not throw errors (or handle them internally)</li> <li>The return value of <code>fn</code> is ignored</li> <li><code>tap</code> is executed synchronously in the pipeline</li> </ul>"},{"location":"either/","title":"<code>Either&lt;L, R&gt;</code>","text":"<p><code>Either</code> is used for computations that may fail. It is either a <code>Left&lt;L&gt;</code> (error) or a <code>Right&lt;R&gt;</code> (success).</p> <pre><code>import { Right } from 'holo-fn/either'\n\nconst result = new Right(10)\n  .map(n =&gt; n * 2)\n  .unwrapOr(0)\n\nconsole.log(result); // 20\n</code></pre>"},{"location":"either/#methods","title":"Methods","text":""},{"location":"either/#mapfn-value-r-u-eitherl-u","title":"<code>map(fn: (value: R) =&gt; U): Either&lt;L, U&gt;</code>","text":"<p>Maps over the <code>Right</code> value. Does nothing for <code>Left</code>.</p> <pre><code>import { Either, Left, Right } from \"holo-fn/either\";\n\nconst calculate = (a: number, b: number): Either&lt;string, number&gt; =&gt; {\n  if (b === 0) {\n    return new Left(\"Division by zero\");\n  }\n\n  return new Right(a / b);\n};\n\nconst result1 = calculate(10, 2)\n  .map(n =&gt; n * 2)\n  .unwrapOr(0);\n\nconsole.log(result1); // 10\n\nconst result2 = calculate(10, 0)\n  .map(n =&gt; n * 2)\n  .unwrapOr(0);\n\nconsole.log(result2); // 0\n</code></pre>"},{"location":"either/#mapleftmfn-err-l-m-eitherm-r","title":"<code>mapLeft&lt;M&gt;(fn: (err: L) =&gt; M): Either&lt;M, R&gt;</code>","text":"<p>Maps over the <code>Left</code> value. Does nothing for <code>Right</code>.</p> <pre><code>import { Either, Left, Right } from \"holo-fn/either\";\n\nconst calculate = (a: number, b: number): Either&lt;string, number&gt; =&gt; {\n  if (b === 0) {\n    return new Left(\"Division by zero\");\n  }\n\n  return new Right(a / b);\n};\n\nconst result1 = calculate(10, 2)\n  .map(n =&gt; n * 2)\n  .mapLeft(e =&gt; console.log(`Error: ${e}`)) // No printing here\n  .unwrapOr(0);\n\nconsole.log(result1); // 10\n\nconst result2 = calculate(10, 0)\n  .map(n =&gt; n * 2)\n  .mapLeft(e =&gt; console.log(`Error: ${e}`)) // Prints \"Error: Division by zero\"\n  .unwrapOr(0);\n\nconsole.log(result2); // 0\n</code></pre>"},{"location":"either/#chainfn-value-r-eitherl-u-eitherl-u","title":"<code>chain(fn: (value: R) =&gt; Either&lt;L, U&gt;): Either&lt;L, U&gt;</code>","text":"<p>Chains the transformation if the value is <code>Right</code>. Returns <code>Left</code> otherwise.</p> <pre><code>import { Either, Left, Right } from \"holo-fn/either\";\n\nconst calculate = (a: number, b: number): Either&lt;string, number&gt; =&gt; {\n  if (b === 0) {\n    return new Left(\"Division by zero\");\n  }\n\n  return new Right(a / b);\n};\n\nconst result1 = calculate(12, 2)\n  .chain(n =&gt; n &gt; 5 ? new Right(n * 2) : new Left(\"Result is too small\"))\n  .map(n =&gt; n + 1)\n  .mapLeft(e =&gt; console.log(`Error: ${e}`)) // Not run\n  .unwrapOr(0);\n\n\nconsole.log(result1); // 13\n\nconst result2 = calculate(10, 2)\n  .chain(n =&gt; n &gt; 5 ? new Right(n * 2) : new Left(\"Result is too small\"))\n  .map(n =&gt; n + 1)\n  .mapLeft(e =&gt; console.log(`Error: ${e}`)) // Prints \"Error: Result is too small\"\n  .unwrapOr(0);\n</code></pre>"},{"location":"either/#validatepredicate-value-r-boolean-leftvalue-l-eitherl-r","title":"<code>validate(predicate: (value: R) =&gt; boolean, leftValue: L): Either&lt;L, R&gt;</code>","text":"<p>Validates the <code>Right</code> value based on a predicate. If the predicate returns <code>true</code>, keeps the value. If it returns <code>false</code>, converts to <code>Left</code> with the provided error. Does nothing for <code>Left</code>.</p> <pre><code>import { Left, Right } from 'holo-fn/either';\n\nconst result1 = new Right&lt;string, number&gt;(25).validate((n) =&gt; n &gt;= 18, 'Must be 18+');\nconsole.log(result1.unwrapOr(0)); // 25\n\nconst result2 = new Right&lt;string, number&gt;(15).validate((n) =&gt; n &gt;= 18, 'Must be 18+');\nconsole.log(result2.isLeft()); // true\nconsole.log(result2.unwrapOr(0)); // 0\n\nconst result3 = new Left&lt;string, number&gt;('Already failed').validate((n) =&gt; n &gt;= 18, 'Must be 18+');\nconsole.log(result3.isLeft()); // true (keeps original error)\n</code></pre>"},{"location":"either/#unwrapordefaultvalue-r-r","title":"<code>unwrapOr(defaultValue: R): R</code>","text":"<p>Returns the value of <code>Right</code>, or the default value for <code>Left</code>.</p> <pre><code>import { Either, Left, Right } from \"holo-fn/either\";\n\nconst calculate = (a: number, b: number): Either&lt;string, number&gt; =&gt; {\n  if (b === 0) {\n    return new Left(\"Division by zero\");\n  }\n\n  return new Right(a / b);\n};\n\nconst result1 = calculate(12, 2).unwrapOr(0);\nconsole.log(result1); // 6\n\nconst result2 = calculate(10, 0).unwrapOr(-1);\nconsole.log(result2); // -1\n</code></pre>"},{"location":"either/#isright-boolean","title":"<code>isRight(): boolean</code>","text":"<p>Checks if the value is <code>Right</code>.</p> <pre><code>import { Either, Left, Right } from \"holo-fn/either\";\n\nconst calculate = (a: number, b: number): Either&lt;string, number&gt; =&gt; {\n  if (b === 0) {\n    return new Left(\"Division by zero\");\n  }\n\n  return new Right(a / b);\n};\n\nconst result1 = calculate(12, 2).isRight();\nconsole.log(result1); // true\n\nconst result2 = calculate(10, 0).isRight();\nconsole.log(result2); // false\n</code></pre>"},{"location":"either/#isleft-boolean","title":"<code>isLeft(): boolean</code>","text":"<p>Checks if the value is <code>Left</code>.</p> <pre><code>import { Either, Left, Right } from \"holo-fn/either\";\n\nconst calculate = (a: number, b: number): Either&lt;string, number&gt; =&gt; {\n  if (b === 0) {\n    return new Left(\"Division by zero\");\n  }\n\n  return new Right(a / b);\n};\n\nconst result1 = calculate(12, 2).isLeft();\nconsole.log(result1); // false\n\nconst result2 = calculate(10, 0).isLeft();\nconsole.log(result2); // true\n</code></pre>"},{"location":"either/#matchtcases-left-left-l-t-right-right-r-t-t","title":"<code>match&lt;T&gt;(cases: { left: (left: L) =&gt; T; right: (right: R) =&gt; T }): T</code>","text":"<p>Matches the value to execute either the <code>left</code> or <code>right</code> case.</p> <pre><code>import { Either, Left, Right } from \"holo-fn/either\";\n\nconst calculate = (a: number, b: number): Either&lt;string, number&gt; =&gt; {\n  if (b === 0) {\n    return new Left(\"Division by zero\");\n  }\n\n  return new Right(a / b);\n};\n\nconst result1 = calculate(12, 2)\n  .chain(n =&gt; n &gt; 5 ? new Right(n * 2) : new Left(\"Result is too small\"))\n  .map(n =&gt; n + 1)\n  .match({\n    right: n =&gt; n,\n    left: e =&gt; {\n      console.log(`Error: ${e}`); // Not run\n      return 0;\n    }\n  });\n\nconsole.log(result1); // 13\n\nconst result2 = calculate(10, 2)\n  .chain(n =&gt; n &gt; 5 ? new Right(n * 2) : new Left(\"Result is too small\"))\n  .map(n =&gt; n + 1)\n  .match({\n    right: n =&gt; n,\n    left: e =&gt; {\n      console.log(`Error: ${e}`); // Prints \"Error: Result is too small\"\n      return 0;\n    }\n  });\n\nconsole.log(result2); // 0\n</code></pre>"},{"location":"either/#equalsother-eitherl-r-boolean","title":"<code>equals(other: Either&lt;L, R&gt;): boolean</code>","text":"<p>Compares <code>this</code> to another <code>Either</code>, returns <code>false</code> if the values inside are different.</p> <pre><code>import { type Either, Left, Right } from \"holo-fn/either\";\n\nconst calculate = (a: number, b: number): Either&lt;string, number&gt; =&gt; {\n  if (b === 0) {\n    return new Left(\"Division by zero\");\n  }\n\n  return new Right(a / b);\n};\n\nconst result1 = calculate(12, 2)\n  .chain(n =&gt; n &gt; 5 ? new Right(n * 2) : new Left(\"Result is too small\"))\n  .map(n =&gt; n + 1);\n\nconsole.log(result1.equals(new Right(13))); // true\n\nconst result2 = calculate(10, 2)\n  .chain(n =&gt; n &gt; 5 ? new Right(n * 2) : new Left(\"Result is too small\"))\n  .map(n =&gt; n + 1);\n\nconsole.log(result2.equals(new Right(0))); // false\n</code></pre>"},{"location":"either/#helpers","title":"Helpers","text":""},{"location":"either/#leftl-r-nevervalue-l-eitherl-r","title":"<code>left&lt;L, R = never&gt;(value: L): Either&lt;L, R&gt;</code>","text":"<p>Creates a <code>Left</code> value, representing an error or failure in an operation.</p> <pre><code>import { left } from 'holo-fn/either';\n\nconst eitherValue = left&lt;string, string&gt;(\"Error\");\nconsole.log(eitherValue.unwrapOr(\"No error\")); // \"No error\"\n</code></pre>"},{"location":"either/#rightl-rvalue-r-eitherl-r","title":"<code>right&lt;L, R&gt;(value: R): Either&lt;L, R&gt;</code>","text":"<p>Creates a <code>Right</code> value, representing a success in an operation.</p> <pre><code>import { right } from 'holo-fn/either';\n\nconst eitherValue = right(10);\nconsole.log(eitherValue.unwrapOr(0)); // 10\n</code></pre>"},{"location":"either/#trycatchfn-onerror","title":"<code>tryCatch(fn, onError?)</code>","text":"<p>Wraps a potentially throwing function in an <code>Either</code>.</p> <pre><code>import { tryCatch } from 'holo-fn/either';\n\nconst input = '{\"name\": \"John Doe\"}'\n\ninterface User {\n    name: string;\n}\n\nconst convertToJson = (obj: unknown): User =&gt; {\n  if (typeof obj === 'object' &amp;&amp; obj !== null &amp;&amp; 'name' in obj) {\n    return obj as User;\n  }\n\n  return { name: 'anonymous' };\n}\n\nconst parsed = tryCatch(() =&gt; JSON.parse(input), e =&gt; 'Invalid JSON')\n  .map(convertToJson)\n  .unwrapOr({ name: 'anonymous 1' });\n\nconsole.log(parsed.name) // John Doe\n</code></pre> <ul> <li>Returns <code>Right&lt;R&gt;</code> if <code>fn()</code> succeeds</li> <li>Returns <code>Left&lt;L&gt;</code> if it throws, using <code>onError</code> if provided</li> </ul>"},{"location":"either/#frompromisepromise-onerror","title":"<code>fromPromise(promise, onError?)</code>","text":"<p>Wraps a <code>Promise&lt;T&gt;</code> into a <code>Promise&lt;Either&lt;L, R&gt;&gt;</code>.</p> <pre><code>import { fromPromise } from 'holo-fn/either'\n\nconst result = await fromPromise(fetch('/api'), e =&gt; 'Network error')\n\nconsole.log(result) // _Left { value: 'Network error' }\n</code></pre> <ul> <li>Resolves to <code>Right&lt;R&gt;</code> on success</li> <li>Resolves to <code>Left&lt;L&gt;</code> on failure</li> </ul>"},{"location":"either/#fromasyncfn-onerror","title":"<code>fromAsync(fn, onError?)</code>","text":"<p>Same as <code>fromPromise</code>, but lazy \u2014 receives a function returning a Promise.</p> <pre><code>import { fromAsync } from 'holo-fn/either'\n\nconst result = await fromAsync(async () =&gt; await fetch('/api'), e =&gt; 'Request failed')\n\nconsole.log(result) // _Left { value: 'Request failed' }\n</code></pre> <ul> <li>Allows deferred execution</li> <li>Handles exceptions from <code>async () =&gt; ...</code></li> </ul>"},{"location":"either/#curried-helpers","title":"Curried Helpers","text":""},{"location":"either/#map","title":"<code>map</code>","text":"<p>Curried version of <code>map</code> for <code>Either</code>. This allows functional composition with <code>pipe</code>.</p> <pre><code>import { map, Right } from 'holo-fn/either';\n\nconst result = pipe(\n  new Right(5),\n  map((x) =&gt; x * 2),\n  (res) =&gt; res.unwrapOr(0)\n);\n\nconsole.log(result); // 10\n</code></pre>"},{"location":"either/#mapleft","title":"<code>mapLeft</code>","text":"<p>Curried version of <code>mapLeft</code> for <code>Either</code>. This allows mapping over the Left value in a functional pipeline.</p> <pre><code>import { Left, mapLeft } from 'holo-fn/either';\n\nconst result = pipe(\n  new Left&lt;string, string&gt;(\"Error\"),\n  mapLeft((e) =&gt; `Mapped error: ${e}`),\n  (res) =&gt; res.unwrapOr(\"No value\") \n);\n\nconsole.log(result); // \"No value\"\n</code></pre>"},{"location":"either/#chain","title":"<code>chain</code>","text":"<p>Curried version of <code>chain</code> for <code>Either</code>. This allows chaining transformations on the Right value of <code>Either</code>, using a functional composition style.</p> <pre><code>import { Right, chain } from 'holo-fn/either';\n\nconst result = pipe(\n  new Right(5),\n  chain((x) =&gt; new Right(x + 5)),\n  (res) =&gt; res.unwrapOr(0)\n);\n\nconsole.log(result); // 10\n</code></pre>"},{"location":"either/#validate","title":"<code>validate</code>","text":"<p>Curried version of <code>validate</code> for <code>Either</code>. This allows filtering/validating values in a functional pipeline with custom error values.</p> <pre><code>import { right, validate, unwrapOr } from 'holo-fn/either';\n\nconst validateAge = (age: number) =&gt;\n  pipe(\n    right&lt;string, number&gt;(age),\n    validate((x: number) =&gt; x &gt;= 0, 'Age cannot be negative'),\n    validate((x: number) =&gt; x &lt;= 150, 'Age too high'),\n    validate((x: number) =&gt; x &gt;= 18, 'Must be 18+'),\n    unwrapOr(0)\n  );\n\nconsole.log(validateAge(25)); // 25\nconsole.log(validateAge(15)); // 0 (fails validation)\n</code></pre> <p>Common use cases:</p> <pre><code>import { right, tryCatch, validate } from 'holo-fn/either';\n\n// Validate email format\nconst validateEmail = (email: string) =&gt;\n  pipe(\n    right&lt;string, string&gt;(email),\n    validate((s: string) =&gt; s.length &gt; 0, 'Email is required'),\n    validate((s: string) =&gt; s.includes('@'), 'Must contain @'),\n    validate((s: string) =&gt; s.includes('.'), 'Invalid domain')\n  );\n\nconsole.log(validateEmail('test@example.com').unwrapOr('Invalid email'));\n\n// Parse and validate numbers\nconst parsePositive = (input: string) =&gt;\n  pipe(\n    tryCatch(\n      () =&gt; parseInt(input, 10),\n      () =&gt; 'Invalid number'\n    ),\n    validate((n: number) =&gt; !isNaN(n), 'Not a number'),\n    validate((n: number) =&gt; n &gt; 0, 'Must be positive')\n  );\n\nconsole.log(parsePositive('42').unwrapOr(0));\n\n// Validate with structured errors\ntype ValidationError = { code: string; message: string };\nconst validateUser = (age: number) =&gt;\n  pipe(\n    right&lt;ValidationError, number&gt;(age),\n    validate((x: number) =&gt; x &gt;= 18, { code: 'AGE_ERROR', message: 'Must be 18+' })\n  );\n\nconsole.log(validateUser(20));\nconsole.log(validateUser(15));\n</code></pre>"},{"location":"either/#unwrapor","title":"<code>unwrapOr</code>","text":"<p>Curried version of <code>unwrapOr</code> for <code>Either</code>. This provides a cleaner way to unwrap the value in a <code>Either</code>, returning a default value if it's <code>Left</code>.</p> <pre><code>import { Left, unwrapOr } from 'holo-fn/either';\n\nconst result = pipe(\n  new Left&lt;string, string&gt;(\"Fail\"),\n  unwrapOr(\"No value\")\n);\n\nconsole.log(result); // \"No value\"\n</code></pre>"},{"location":"either/#match","title":"<code>match</code>","text":"<p>Curried version of <code>match</code> for <code>Either</code>. This allows handling <code>Left</code> and <code>Right</code> in a functional way.</p> <pre><code>import { match, Right } from 'holo-fn/either';\n\nconst result = pipe(\n  new Right&lt;string, number&gt;(10),\n  match({\n    left: (e) =&gt; `Error: ${e}`,\n    right: (v) =&gt; `Success: ${v}`\n  })\n);\n\nconsole.log(result); // \"Success: 10\"\n</code></pre>"},{"location":"either/#equals","title":"<code>equals</code>","text":"<p>Curried version of <code>equals</code> for <code>Either</code>. Compares <code>this</code> to another <code>Either</code>, returns <code>false</code> if the values inside are different.</p> <pre><code>import { equals, Right } from 'holo-fn/either';\nimport { pipe } from 'remeda';\n\nconst result = pipe(\n  new Right(10),\n  equals(new Right(10))\n);\n\nconsole.log(result); // true\n</code></pre>"},{"location":"either/#all","title":"<code>all</code>","text":"<p>Combines an array of <code>Either</code> values into a single <code>Either</code>. Returns <code>Right</code> with all values if all are <code>Right</code>, or <code>Left</code> with all errors if any are <code>Left</code>.</p> <pre><code>import { all, left, right, type Either } from 'holo-fn/either';\n\nconst result1: Either&lt;unknown, number[]&gt; = all([right(1), right(2), right(3)]);\nconsole.log(result1.unwrapOr([])); // [1, 2, 3]\n\nconst result2 = all([left('Name required'), left('Email invalid'), right(25)]);\nconsole.log(\n  result2.match({\n    left: (e) =&gt; e,\n    right: (v) =&gt; v,\n  })\n); // ['Name required', 'Email invalid']\n\n// Empty array\nconst result3 = all([]);\nconsole.log(result3.unwrapOr([])); // []\n</code></pre>"},{"location":"either/#sequence","title":"<code>sequence</code>","text":"<p>Combines an array of <code>Either</code> values into a single <code>Either</code>, stopping at the first error (fail-fast). Returns <code>Right</code> with all values if all are <code>Right</code>, or <code>Left</code> with the first error encountered.</p> <p>Unlike <code>all</code> which collects all errors, <code>sequence</code> returns immediately when it finds the first <code>Left</code>.</p> <pre><code>import { left, right, sequence, type Either } from 'holo-fn/either';\n\nconst result1: Either&lt;unknown, number[]&gt; = sequence([right(1), right(2), right(3)]);\nconsole.log(result1.unwrapOr([])); // [1, 2, 3]\n\nconst result2 = sequence([\n  right(1),\n  left('First error'),\n  left('Second error')\n]);\nconsole.log(result2.match({\n  left: (e) =&gt; e,\n  right: (v) =&gt; v\n})); // 'First error' (not an array!)\n</code></pre>"},{"location":"either/#partition","title":"<code>partition</code>","text":"<p>Separates an array of <code>Either</code> values into two groups: <code>lefts</code> and <code>rights</code>. Always processes all items and returns both arrays.</p> <p>Unlike <code>all</code> and <code>sequence</code> which return an <code>Either</code>, <code>partition</code> returns a plain object with two arrays.</p> <pre><code>import { left, partition, right } from 'holo-fn/either';\n\nconst eithers = [\n  right&lt;string, number&gt;(1),\n  left('error1'),\n  right&lt;string, number&gt;(2),\n  left('error2'),\n  right&lt;string, number&gt;(3),\n];\n\nconst { lefts, rights } = partition(eithers);\nconsole.log(rights); // [1, 2, 3]\nconsole.log(lefts); // ['error1', 'error2']\n\nconst { lefts: errors, rights: values } = partition(eithers);\nconsole.log(`\u2713 ${values.length} succeeded`);\nconsole.log(`\u2717 ${errors.length} failed`);\nerrors.forEach((err) =&gt; console.error(err));\n</code></pre>"},{"location":"either/#common-patterns","title":"Common Patterns","text":""},{"location":"either/#discriminated-union-errors","title":"Discriminated union errors","text":"<pre><code>import { left, match, type Either } from 'holo-fn/either';\nimport { pipe } from 'rambda';\n\ntype User = {\n  name: string;\n  email: string;\n};\n\ntype ValidationError =\n  | { type: 'INVALID_EMAIL'; email: string }\n  | { type: 'TOO_SHORT'; minLength: number }\n  | { type: 'REQUIRED'; field: string };\n\nconst result: Either&lt;ValidationError, User&gt; = left({\n  type: 'INVALID_EMAIL',\n  email: 'bad@email',\n});\n\nconst message = pipe(\n  result,\n  match({\n    left: (err) =&gt; {\n      switch (err.type) {\n        case 'INVALID_EMAIL':\n          return `Invalid email: ${err.email}`;\n        case 'TOO_SHORT':\n          return `Must be at least ${err.minLength} characters`;\n        case 'REQUIRED':\n          return `Field ${err.field} is required`;\n      }\n    },\n    right: (user) =&gt; `Success: ${user.name}`,\n  })\n);\n</code></pre>"},{"location":"either/#batch-operations-with-error-tracking","title":"Batch operations with error tracking","text":"<pre><code>import { all, left, match, right } from 'holo-fn/either';\nimport { pipe } from 'rambda';\n\ntype AddressData = {\n  street: string;\n  city: string;\n  zip: string;\n};\n\ntype UserData = {\n  email: string;\n  age: number;\n  address: AddressData;\n};\n\nconst validateEmail = (email: string) =&gt; (email.includes('@') ? right(email) : left('Invalid email'));\n\nconst validateAge = (age: number) =&gt; (age &gt;= 18 ? right(age) : left('Must be 18+'));\n\nconst validateAddress = (address: AddressData) =&gt; {\n  if (!address.street || !address.city || !address.zip) {\n    return left('Incomplete address');\n  }\n  return right(address);\n};\n\nconst validateForm = (data: UserData) =&gt;\n  pipe(\n    all([validateEmail(data.email), validateAge(data.age), validateAddress(data.address)]),\n    match({\n      left: (err) =&gt; `Validation failed: ${err}`,\n      right: ([email, age, address]) =&gt;\n        `Validation succeeded: ${email}, ${age}, ${address.street}, ${address.city}, ${address.zip}`,\n    })\n  );\n\nconsole.log(\n  validateForm({\n    email: 'user@example.com',\n    age: 25,\n    address: {\n      street: '123 Main St',\n      city: 'Anytown',\n      zip: '12345',\n    },\n  })\n);\n</code></pre>"},{"location":"helpers/inspect/","title":"inspect","text":"<p>Logs a value with an optional label and returns it unchanged. A specialized version of <code>tap</code> for debugging that automatically logs to <code>console.log</code>.</p>"},{"location":"helpers/inspect/#signature","title":"Signature","text":"<pre><code>function inspect&lt;T&gt;(label?: string): (value: T) =&gt; T\n</code></pre>"},{"location":"helpers/inspect/#parameters","title":"Parameters","text":"<ul> <li><code>label</code> (optional): A string label to prefix the logged value</li> </ul>"},{"location":"helpers/inspect/#returns","title":"Returns","text":"<p>A function that: - Takes a value of any type - Logs it to console (with label if provided) - Returns the value unchanged</p>"},{"location":"helpers/inspect/#usage","title":"Usage","text":""},{"location":"helpers/inspect/#basic-usage-with-label","title":"Basic Usage with Label","text":"<pre><code>import { pipe } from 'rambda';\nimport { just, map } from 'holo-fn/maybe';\nimport { inspect } from 'holo-fn';\n\npipe(\n  just(42),\n  map(x =&gt; x * 2),\n  inspect('After doubling'),  // Logs: \"After doubling: Just(84)\"\n  map(x =&gt; x + 10)\n);\n</code></pre>"},{"location":"helpers/inspect/#without-label","title":"Without Label","text":"<pre><code>import { inspect } from 'holo-fn';\nimport { map, ok } from 'holo-fn/result';\nimport { pipe } from 'rambda';\n\npipe(\n  ok({ id: 1, name: 'Alice' }),\n  inspect(),  // Logs: Ok({ id: 1, name: 'Alice' })\n  map(user =&gt; user.name)\n);\n</code></pre>"},{"location":"helpers/inspect/#debugging-pipelines","title":"Debugging Pipelines","text":"<pre><code>import { inspect } from 'holo-fn';\nimport { just, map } from 'holo-fn/maybe';\nimport { pipe } from 'rambda';\n\nconst result = pipe(\n  just(10),\n  inspect('Initial value'),      // Logs: \"Initial value: Just(10)\"\n  map(x =&gt; x * 2),\n  inspect('After doubling'),      // Logs: \"After doubling: Just(20)\"\n  map(x =&gt; x + 5),\n  inspect('Final result')         // Logs: \"Final result: Just(25)\"\n);\n</code></pre>"},{"location":"helpers/inspect/#with-arrays","title":"With Arrays","text":"<pre><code>import { inspect } from 'holo-fn';\nimport { pipe } from 'rambda';\n\npipe(\n  [1, 2, 3, 4],\n  inspect('Initial array'),       // Logs: \"Initial array: [1, 2, 3, 4]\"\n  arr =&gt; arr.filter(x =&gt; x &gt; 2),\n  inspect('After filter'),        // Logs: \"After filter: [3, 4]\"\n  arr =&gt; arr.map(x =&gt; x * 2),\n  inspect('Final result')         // Logs: \"Final result: [6, 8]\"\n);\n</code></pre>"},{"location":"helpers/inspect/#with-plain-objects","title":"With Plain Objects","text":"<pre><code>import { inspect } from 'holo-fn';\nimport { pipe } from 'rambda';\n\nconst user = pipe(\n  { id: 1, name: 'Alice', age: 30 },\n  inspect('User data'),           // Logs: \"User data: { id: 1, name: 'Alice', age: 30 }\"\n  user =&gt; ({ ...user, age: user.age + 1 }),\n  inspect('After birthday')       // Logs: \"After birthday: { id: 1, name: 'Alice', age: 31 }\"\n);\n</code></pre>"},{"location":"helpers/inspect/#common-use-cases","title":"Common Use Cases","text":""},{"location":"helpers/inspect/#debugging-complex-transformations","title":"Debugging Complex Transformations","text":"<pre><code>import { inspect } from 'holo-fn';\nimport { chain, fromNullable, map } from 'holo-fn/maybe';\nimport { pipe } from 'rambda';\n\nconst getUserEmail = (userId: number) =&gt;\n  pipe(\n    fetchUser(userId),\n    fromNullable,\n    inspect('User fetched'),\n    map(user =&gt; user.profile),\n    inspect('Profile extracted'),\n    chain(profile =&gt; fromNullable(profile.email)),\n    inspect('Email result')\n  );\n</code></pre>"},{"location":"helpers/inspect/#finding-where-transformations-fail","title":"Finding Where Transformations Fail","text":"<pre><code>import { inspect } from 'holo-fn';\nimport { fromThrowable, map } from 'holo-fn/result';\nimport { pipe } from 'rambda';\n\nconst parseAndValidate = (input: string) =&gt;\n  pipe(\n    input,\n    inspect('Raw input'),\n    fromThrowable(JSON.parse),\n    inspect('After parsing'),      // See if parsing succeeded\n    map(validateSchema),\n    inspect('After validation')    // See validation result\n  );\n</code></pre>"},{"location":"helpers/inspect/#monitoring-data-flow","title":"Monitoring Data Flow","text":"<pre><code>import { inspect } from 'holo-fn';\nimport { all, map } from 'holo-fn/maybe';\nimport { pipe } from 'rambda';\n\nconst results = pipe(\n  [\n    fetchData(1),\n    fetchData(2),\n    fetchData(3)\n  ],\n  inspect('Individual results'),\n  all,\n  inspect('Combined result'),\n  map(data =&gt; processData(data)),\n  inspect('Processed data')\n);\n</code></pre>"},{"location":"helpers/inspect/#differences-from-tap","title":"Differences from <code>tap</code>","text":"<p>While <code>tap</code> is a generic utility for any side-effect, <code>inspect</code> is specialized for logging:</p> <pre><code>// tap - generic, you provide the logging logic\ntap(x =&gt; console.log('Value:', x))\n\n// inspect - specialized for logging, with optional label\ninspect('Value')\n</code></pre> <p>Both are useful: - Use <code>tap</code> when you need custom side-effects (metrics, validation, etc.) - Use <code>inspect</code> for quick debugging with console.log</p>"},{"location":"helpers/inspect/#key-features","title":"Key Features","text":"<ul> <li>\u2705 Non-intrusive: Doesn't modify the value or pipeline flow</li> <li>\u2705 Type-safe: Preserves type information through the pipeline</li> <li>\u2705 Flexible: Works with any type (monads, primitives, objects, arrays)</li> <li>\u2705 Convenient: Automatic <code>console.log</code> with optional labeling</li> <li>\u2705 Composable: Easy to add/remove in pipelines during debugging</li> </ul>"},{"location":"helpers/inspect/#tips","title":"Tips","text":"<ol> <li>Add labels for clarity in complex pipelines</li> <li>Remove or comment out <code>inspect</code> calls before production</li> <li>Combine with <code>tap</code> for custom logging behavior</li> <li>Use descriptive labels to track transformation stages</li> <li>Remember it always uses <code>console.log</code> - use <code>tap</code> for custom logging</li> </ol>"},{"location":"helpers/inspect/#type-safety","title":"Type Safety","text":"<p><code>inspect</code> is fully type-safe and preserves types:</p> <pre><code>const value: Maybe&lt;number&gt; = pipe(\n  just(42),\n  inspect('Number'),  // Type: Maybe&lt;number&gt;\n  map(x =&gt; x * 2)     // x is correctly inferred as number\n);\n</code></pre>"},{"location":"helpers/inspect/#related","title":"Related","text":"<ul> <li><code>tap</code> - Generic side-effect utility</li> <li>Maybe</li> <li>Result</li> <li>Either</li> </ul>"},{"location":"helpers/tap/","title":"tap","text":"<p>A utility function for executing side-effects in functional pipelines without altering the data flow.</p>"},{"location":"helpers/tap/#overview","title":"Overview","text":"<p><code>tap</code> allows you to perform side-effects (like logging, debugging, or metrics) in the middle of a pipeline while keeping the data unchanged. It's a generic function that works with any value type - monads, arrays, objects, primitives, etc.</p>"},{"location":"helpers/tap/#signature","title":"Signature","text":"<pre><code>function tap&lt;T&gt;(fn: (value: T) =&gt; void): (value: T) =&gt; T\n</code></pre>"},{"location":"helpers/tap/#parameters","title":"Parameters","text":"<ul> <li><code>fn</code>: A function that receives the value and performs a side-effect (returns void)</li> </ul>"},{"location":"helpers/tap/#returns","title":"Returns","text":"<p>A function that: 1. Takes a value of type <code>T</code> 2. Executes the side-effect function with that value 3. Returns the original value unchanged</p>"},{"location":"helpers/tap/#usage","title":"Usage","text":""},{"location":"helpers/tap/#with-maybe","title":"With Maybe","text":"<pre><code>import { tap } from \"holo-fn\";\nimport { just, map } from \"holo-fn/maybe\";\nimport { pipe } from \"rambda\";\n\nconst result = pipe(\n  just(42),\n  tap(m =&gt; console.log(\"Maybe:\", m.unwrapOr(0))),\n  map(x =&gt; x * 2),\n  tap(m =&gt; console.log(\"After map:\", m.unwrapOr(0)))\n);\n// Logs: \"Maybe: 42\"\n// Logs: \"After map: 84\"\n// Returns: Just(84)\n</code></pre>"},{"location":"helpers/tap/#with-result","title":"With Result","text":"<pre><code>import { tap } from \"holo-fn\";\nimport { map, ok } from \"holo-fn/result\";\nimport { pipe } from \"rambda\";\n\nconst result = pipe(\n  ok(100),\n  tap(r =&gt; console.log(\"Initial:\", r.unwrapOr(0))),\n  map(x =&gt; x / 2),\n  tap(r =&gt; console.log(\"After division:\", r.unwrapOr(0)))\n);\n// Logs: \"Initial: 100\"\n// Logs: \"After division: 50\"\n// Returns: Ok(50)\n</code></pre>"},{"location":"helpers/tap/#with-either","title":"With Either","text":"<pre><code>import { tap } from \"holo-fn\";\nimport { map, right } from \"holo-fn/either\";\nimport { pipe } from \"rambda\";\n\nconst result = pipe(\n  right(10),\n  tap(e =&gt; console.log(\"Right value:\", e.unwrapOr(0))),\n  map(x =&gt; x + 5),\n  tap(e =&gt; console.log(\"After adding:\", e.unwrapOr(0)))\n);\n// Logs: \"Right value: 10\"\n// Logs: \"After adding: 15\"\n// Returns: Right(15)\n</code></pre>"},{"location":"helpers/tap/#with-plain-values","title":"With Plain Values","text":"<pre><code>import { tap } from \"holo-fn\";\nimport { pipe } from \"rambda\";\n\nconst result = pipe(\n  42,\n  tap(x =&gt; console.log(\"Initial:\", x)),\n  x =&gt; x * 2,\n  tap(x =&gt; console.log(\"Doubled:\", x)),\n  x =&gt; x + 10,\n  tap(x =&gt; console.log(\"Final:\", x))\n);\n// Logs: \"Initial: 42\"\n// Logs: \"Doubled: 84\"\n// Logs: \"Final: 94\"\n// Returns: 94\n</code></pre>"},{"location":"helpers/tap/#with-arrays","title":"With Arrays","text":"<pre><code>import { tap } from \"holo-fn\";\nimport { pipe } from \"rambda\";\n\nconst result = pipe(\n  [1, 2, 3],\n  tap(arr =&gt; console.log(\"Length:\", arr.length)),\n  arr =&gt; arr.map(x =&gt; x * 2),\n  tap(arr =&gt; console.log(\"After map:\", arr)),\n  arr =&gt; arr.filter(x =&gt; x &gt; 2)\n);\n// Logs: \"Length: 3\"\n// Logs: \"After map: [2, 4, 6]\"\n// Returns: [4, 6]\n</code></pre>"},{"location":"helpers/tap/#with-objects","title":"With Objects","text":"<pre><code>import { tap } from \"holo-fn\";\nimport { pipe } from \"rambda\";\n\nconst result = pipe(\n  { name: \"Alice\", age: 25 },\n  tap(obj =&gt; console.log(\"User:\", obj.name)),\n  obj =&gt; ({ ...obj, age: obj.age + 1 }),\n  tap(obj =&gt; console.log(\"Age updated:\", obj.age))\n);\n// Logs: \"User: Alice\"\n// Logs: \"Age updated: 26\"\n// Returns: { name: \"Alice\", age: 26 }\n</code></pre>"},{"location":"helpers/tap/#common-use-cases","title":"Common Use Cases","text":""},{"location":"helpers/tap/#1-debugging","title":"1. Debugging","text":"<pre><code>const processData = pipe(\n  fetchData(),\n  tap(data =&gt; console.log(\"Raw data:\", data)),\n  parseData,\n  tap(parsed =&gt; console.log(\"Parsed:\", parsed)),\n  validateData,\n  tap(valid =&gt; console.log(\"Validated:\", valid))\n);\n</code></pre>"},{"location":"helpers/tap/#2-logging","title":"2. Logging","text":"<pre><code>const processUser = pipe(\n  getUser(id),\n  tap(user =&gt; logger.info(\"User fetched\", { userId: user.id })),\n  validateUser,\n  tap(user =&gt; logger.info(\"User validated\")),\n  saveUser,\n  tap(user =&gt; logger.info(\"User saved\", { userId: user.id }))\n);\n</code></pre>"},{"location":"helpers/tap/#3-metrics-and-monitoring","title":"3. Metrics and Monitoring","text":"<pre><code>const processOrder = pipe(\n  createOrder(data),\n  tap(order =&gt; metrics.recordOrderCreated(order.id)),\n  validateOrder,\n  tap(order =&gt; metrics.recordOrderValidated()),\n  processPayment,\n  tap(order =&gt; metrics.recordPaymentProcessed())\n);\n</code></pre>"},{"location":"helpers/tap/#4-side-effects-with-conditions","title":"4. Side-effects with Conditions","text":"<pre><code>const processValue = pipe(\n  getValue(),\n  tap(v =&gt; {\n    if (v &gt; 100) {\n      console.warn(\"High value detected:\", v);\n    }\n  }),\n  transform,\n  tap(v =&gt; {\n    if (debug.enabled) {\n      console.log(\"Debug:\", v);\n    }\n  })\n);\n</code></pre>"},{"location":"helpers/tap/#5-error-tracking","title":"5. Error Tracking","text":"<pre><code>const processData = pipe(\n  fetchData(),\n  tap(result =&gt; {\n    if (result.isErr()) {\n      sentry.captureException(result.extract());\n    }\n  }),\n  map(processValue),\n  tap(result =&gt; {\n    if (result.isErr()) {\n      logger.error(\"Processing failed\", result.extract());\n    }\n  })\n);\n</code></pre>"},{"location":"helpers/tap/#key-features","title":"Key Features","text":"<ul> <li>Generic: Works with any type - monads, primitives, objects, arrays</li> <li>Non-intrusive: Doesn't modify the data flowing through the pipeline</li> <li>Composable: Can be used multiple times in a single pipeline</li> <li>Type-safe: TypeScript preserves types correctly</li> <li>Flexible: Suitable for logging, debugging, metrics, or any side-effect</li> </ul>"},{"location":"helpers/tap/#tips","title":"Tips","text":"<ol> <li>Keep side-effects pure from data perspective: <code>tap</code> should not modify the value, only observe or perform external actions</li> <li>Use for observability: Great for adding logging/metrics without cluttering business logic</li> <li>Conditional logging: Wrap debug logs in conditions to avoid performance impact in production</li> <li>Chain multiple taps: Don't hesitate to use multiple <code>tap</code> calls for different concerns</li> </ol>"},{"location":"helpers/tap/#type-safety","title":"Type Safety","text":"<p>TypeScript correctly infers the type through <code>tap</code>:</p> <pre><code>// Type is preserved\nconst result: Maybe&lt;number&gt; = pipe(\n  just(42),\n  tap(x =&gt; console.log(x)), // x: Maybe&lt;number&gt;\n  map(x =&gt; x * 2)           // Type: Maybe&lt;number&gt;\n);\n\n// Works with union types\nconst value: string | number = pipe(\n  getUnionValue(),\n  tap(x =&gt; console.log(typeof x)), // x: string | number\n  transform\n);\n</code></pre>"},{"location":"helpers/tap/#related","title":"Related","text":"<ul> <li><code>map</code> - Transform values</li> <li><code>chain</code> - Chain computations</li> <li><code>match</code> - Pattern matching</li> </ul>"},{"location":"helpers/tap/#notes","title":"Notes","text":"<ul> <li>Side-effects in <code>fn</code> should not throw errors (or handle them internally)</li> <li>The return value of <code>fn</code> is ignored</li> <li><code>tap</code> is executed synchronously in the pipeline</li> </ul>"},{"location":"maybe/","title":"<code>Maybe&lt;T&gt;</code>","text":"<p><code>Maybe</code> is used to represent a value that may or may not exist. It can either be a <code>Just&lt;T&gt;</code> or a <code>Nothing</code>.</p> <pre><code>import { fromNullable } from 'holo-fn/maybe'\n\nconst name = fromNullable('Rich')\n  .map(n =&gt; n.toUpperCase())\n  .unwrapOr('Anonymous')\n\nconsole.log(name) // RICH\n</code></pre>"},{"location":"maybe/#methods","title":"Methods","text":""},{"location":"maybe/#mapfn-value-t-u-maybeu","title":"<code>map(fn: (value: T) =&gt; U): Maybe&lt;U&gt;</code>","text":"<p>Maps over the <code>Just</code> value. Does nothing for <code>Nothing</code>.</p> <pre><code>import { Just, Nothing } from \"holo-fn/maybe\";\n\nconst result1 = new Just(5).map((n) =&gt; n * 2);\nconsole.log(result1.unwrapOr(0)); // 10\n\nconst result2 = new Nothing&lt;number&gt;().map((n) =&gt; n * 2);\nconsole.log(result2.unwrapOr(0)); // 0\n</code></pre>"},{"location":"maybe/#chainfn-value-t-maybeu-maybeu","title":"<code>chain(fn: (value: T) =&gt; Maybe&lt;U&gt;): Maybe&lt;U&gt;</code>","text":"<p>Chains the transformation if the value is <code>Just</code>. Returns <code>Nothing</code> otherwise.</p> <pre><code>import { Just, Nothing } from \"holo-fn/maybe\";\n\nconst result1 = new Just(5).chain((n) =&gt; new Just(n * 2));\nconsole.log(result1.unwrapOr(0)); // 10\n\nconst result2 = new Nothing&lt;number&gt;().chain((n) =&gt; new Just(n * 2));\nconsole.log(result2.unwrapOr(0)); // 0\n</code></pre>"},{"location":"maybe/#filterfn-value-t-boolean-maybet","title":"<code>filter(fn: (value: T) =&gt; boolean): Maybe&lt;T&gt;</code>","text":"<p>Filters the <code>Just</code> value based on a predicate. If the predicate returns <code>true</code>, keeps the value. If it returns <code>false</code>, converts to <code>Nothing</code>. Does nothing for <code>Nothing</code>.</p> <pre><code>import { Just, Nothing } from \"holo-fn/maybe\";\n\nconst result1 = new Just(25).filter((n) =&gt; n &gt;= 18);\nconsole.log(result1.unwrapOr(0)); // 25\n\nconst result2 = new Just(15).filter((n) =&gt; n &gt;= 18);\nconsole.log(result2.unwrapOr(0)); // 0\n\nconst result3 = new Nothing&lt;number&gt;().filter((n) =&gt; n &gt;= 18);\nconsole.log(result3.unwrapOr(0)); // 0\n</code></pre>"},{"location":"maybe/#unwrapordefaultvalue-t-t","title":"<code>unwrapOr(defaultValue: T): T</code>","text":"<p>Returns the value of <code>Just</code>, or the default value for <code>Nothing</code>.</p> <pre><code>import { Just, Nothing } from \"holo-fn/maybe\";\n\nconst result1 = new Just(10);\nconsole.log(result1.unwrapOr(0)); // 10\n\nconst result2 = new Nothing&lt;number&gt;();\nconsole.log(result2.unwrapOr(0)); // 0\n</code></pre>"},{"location":"maybe/#isjust-boolean","title":"<code>isJust(): boolean</code>","text":"<p>Checks if the value is <code>Just</code>.</p> <pre><code>import { Just, Nothing } from \"holo-fn/maybe\";\n\nconst result1 = new Just(\"value\");\nconsole.log(result1.isJust()); // true\n\nconst result2 = new Nothing();\nconsole.log(result2.isJust()); // false\n</code></pre>"},{"location":"maybe/#isnothing-boolean","title":"<code>isNothing(): boolean</code>","text":"<p>Checks if the value is <code>Nothing</code>.</p> <pre><code>import { Just, Nothing } from \"holo-fn/maybe\";\n\nconst result1 = new Just(\"value\");\nconsole.log(result1.isNothing()); // false\n\nconst result2 = new Nothing();\nconsole.log(result2.isNothing()); // true\n</code></pre>"},{"location":"maybe/#matchucases-just-value-t-u-nothing-u-u","title":"<code>match&lt;U&gt;(cases: { just: (value: T) =&gt; U; nothing: () =&gt; U }): U</code>","text":"<p>Matches the value to execute either the <code>just</code> or <code>nothing</code> case.</p> <pre><code>import { Just, Nothing } from \"holo-fn/maybe\";\n\nconst result1 = new Just(\"value\").match({\n  just: (v) =&gt; `Has value: ${v}`,\n  nothing: () =&gt; \"No value\",\n});\nconsole.log(result1); // \"Has value: value\"\n\nconst result2 = new Nothing().match({\n  just: (v) =&gt; `Has value: ${v}`,\n  nothing: () =&gt; \"No value\",\n});\nconsole.log(result2); // \"No value\"\n</code></pre>"},{"location":"maybe/#equalsother-maybet-boolean","title":"<code>equals(other: Maybe&lt;T&gt;): boolean</code>","text":"<p>Compares the values inside <code>this</code> and the other, returns <code>true</code> if both are <code>Nothing</code> or if the values are equal.</p> <pre><code>import type { Maybe } from \"holo-fn\";\nimport { Just, Nothing } from \"holo-fn/maybe\";\n\nconst result1 = new Just(\"value\").chain(v =&gt; new Just(v + \" modified\"));\n\nconsole.log(result1.equals(new Just(\"value\"))); // false\nconsole.log(result1.equals(new Just(\"value modified\"))); // true\n\nconst result2: Maybe&lt;string&gt; = new Just(\"value\").chain(v =&gt; new Nothing());\nconsole.log(result2.equals(new Nothing())); // true\nconsole.log(result2.equals(new Just(\"value\"))); // false\n</code></pre>"},{"location":"maybe/#helpers","title":"Helpers","text":""},{"location":"maybe/#justvalue-t-maybet","title":"<code>just(value: T): Maybe&lt;T&gt;</code>","text":"<p>Creates a <code>Just</code> value with the given value, representing the presence of a value.</p> <pre><code>import { just } from 'holo-fn/maybe';\n\nconst maybeValue = just('Hello');\nconsole.log(maybeValue.unwrapOr('Default')); // 'Hello'\n</code></pre>"},{"location":"maybe/#nothingt-never-maybet","title":"<code>nothing&lt;T = never&gt;(): Maybe&lt;T&gt;</code>","text":"<p>Creates a <code>Nothing</code> value, representing the absence of a value.</p> <pre><code>import { nothing } from 'holo-fn/maybe';\n\nconst maybeValue = nothing&lt;string&gt;();\nconsole.log(maybeValue.unwrapOr('Default')); // 'Default'\n</code></pre>"},{"location":"maybe/#fromnullablevalue","title":"<code>fromNullable(value)</code>","text":"<p>Creates a <code>Maybe</code> from a value that might be <code>null</code> or <code>undefined</code>.</p> <pre><code>const maybeEmail = fromNullable(user.email)\n</code></pre> <ul> <li>Returns <code>Just&lt;T&gt;</code> if the value is not <code>null</code> or <code>undefined</code></li> <li>Returns <code>Nothing</code> otherwise</li> </ul>"},{"location":"maybe/#curried-helpers","title":"Curried Helpers","text":""},{"location":"maybe/#map","title":"<code>map</code>","text":"<p>Curried version of <code>map</code> for <code>Maybe</code>. This allows functional composition with <code>pipe</code>.</p> <pre><code>import { Just, map } from 'holo-fn/maybe';\n\nconst result = pipe(\n  new Just(10),\n  map((x) =&gt; x * 2),\n  (res) =&gt; res.unwrapOr(0)\n);\n\nconsole.log(result); // 20\n</code></pre>"},{"location":"maybe/#chain","title":"<code>chain</code>","text":"<p>Curried version of <code>chain</code> for <code>Maybe</code>. This allows chaining transformations in a functional pipeline.</p> <pre><code>import { chain, Just } from 'holo-fn/maybe';\n\nconst result = pipe(\n  new Just(2),\n  chain((x) =&gt; new Just(x * 10)),\n  (res) =&gt; res.unwrapOr(0)\n);\n\nconsole.log(result); // 20\n</code></pre>"},{"location":"maybe/#filter","title":"<code>filter</code>","text":"<p>Curried version of <code>filter</code> for <code>Maybe</code>. This allows filtering values in a functional pipeline based on a predicate.</p> <pre><code>import { filter, just } from 'holo-fn/maybe';\n\nconst result = pipe(\n  just(25),\n  filter((x) =&gt; x &gt;= 18),\n  filter((x) =&gt; x &lt;= 100),\n  (res) =&gt; res.unwrapOr(0)\n);\n\nconsole.log(result); // 25\n\n// Validate age\nconst validateAge = (age: number) =&gt;\n  pipe(\n    just(age),\n    filter((x) =&gt; x &gt;= 0),\n    filter((x) =&gt; x &lt;= 150),\n    filter((x) =&gt; x &gt;= 18)\n  );\n\nconsole.log(validateAge(151).unwrapOr(0)); // 25\n\n// Validate email format\nconst validateEmail = (email: string) =&gt;\n  pipe(\n    just(email),\n    filter((s) =&gt; s.length &gt; 0),\n    filter((s) =&gt; s.includes('@')),\n    filter((s) =&gt; s.split('@')[1]?.includes('.') ?? false)\n  );\n\nconsole.log(validateEmail('test@example.com').unwrapOr('Invalid email'));\n\n// Parse positive integers\nconst parsePositive = (input: string) =&gt;\n  pipe(\n    just(input),\n    map((s) =&gt; parseInt(s, 10)),\n    filter((n) =&gt; !isNaN(n)),\n    filter((n) =&gt; n &gt; 0)\n  );\n\nconsole.log(parsePositive('42').unwrapOr(0)); // 42\n</code></pre>"},{"location":"maybe/#unwrapor","title":"<code>unwrapOr</code>","text":"<p>Curried version of <code>unwrapOr</code> for <code>Maybe</code>. This provides a cleaner way to unwrap the value in a <code>Maybe</code>.</p> <pre><code>import { Nothing, unwrapOr } from 'holo-fn/maybe';\n\nconst result = pipe(\n  new Nothing&lt;string&gt;(),\n  unwrapOr(\"No value\")\n);\n\nconsole.log(result); // \"No value\"\n</code></pre>"},{"location":"maybe/#match","title":"<code>match</code>","text":"<p>Curried version of <code>match</code> for <code>Maybe</code>. This allows handling <code>Just</code> and <code>Nothing</code> in a functional way.</p> <pre><code>import { Just, match } from 'holo-fn/maybe';\n\nconst result = pipe(\n  new Just(\"hello\"),\n  match({\n    just: (v) =&gt; `Got ${v}`,\n    nothing: () =&gt; \"No value\"\n  })\n);\n\nconsole.log(result); // \"Got hello\"\n</code></pre>"},{"location":"maybe/#equals","title":"<code>equals</code>","text":"<p>Curried version of <code>equals</code> for <code>Maybe</code>. Compares the values inside <code>this</code> and the other, returns <code>true</code> if both are <code>Nothing</code> or if the values are equal.</p> <pre><code>import { equals, Just } from 'holo-fn/maybe';\n\nconst result = pipe(\n  new Just(10),\n  equals(new Just(10))\n);\n\nconsole.log(result); // true\n</code></pre>"},{"location":"maybe/#all","title":"<code>all</code>","text":"<p>Combines an array of <code>Maybe</code> values into a single <code>Maybe</code> containing an array. Returns <code>Just</code> with all values if all are <code>Just</code>, or <code>Nothing</code> if any is <code>Nothing</code>.</p> <pre><code>import { all, just, nothing, type Maybe } from 'holo-fn/maybe';\n\n// All success case\nconst result1: Maybe&lt;number[]&gt; = all([just(1), just(2), just(3)]);\nconsole.log(result1.unwrapOr([])); // [1, 2, 3]\n\n// Any failure case\nconst result2 = all([just(1), nothing(), just(3)]);\nconsole.log(result2.isNothing()); // true\n\n// Empty array\nconst result3 = all([]);\nconsole.log(result3.unwrapOr([])); // []\n</code></pre>"},{"location":"maybe/#common-patterns","title":"Common Patterns","text":""},{"location":"maybe/#combining-multiple-maybes","title":"Combining multiple Maybes","text":"<p>When you need to work with multiple <code>Maybe</code> values:</p> <pre><code>import { all, just, match } from 'holo-fn/maybe';\nimport { pipe } from 'rambda';\n\nconst name = just('Test User');\nconst age = just(25);\nconst email = just('testuser@example.com');\n\nconst user = pipe(\n  all([name, age, email]),\n  match({\n    just: ([n, a, e]) =&gt; ({ name: n, age: a, email: e }),\n    nothing: () =&gt; null,\n  })\n);\n\nconsole.log(user);\n// Output: { name: 'Test User', age: 25, email: 'testuser@example.com' }\n</code></pre>"},{"location":"maybe/#conditional-logic-with-predicates","title":"Conditional logic with predicates","text":"<pre><code>import { just, match } from 'holo-fn/maybe';\nimport { pipe } from 'rambda';\n\nconst value = just(42);\n\nconst category = pipe(\n  value,\n  match({\n    just: (v) =&gt; {\n      if (v &gt; 100) return 'big';\n      if (v &gt; 50) return 'medium';\n      return 'small';\n    },\n    nothing: () =&gt; 'unknown',\n  })\n);\n\nconsole.log(`The number is categorized as: ${category}`);\n</code></pre>"},{"location":"maybe/#chaining-operations-with-early-exit","title":"Chaining operations with early exit","text":"<pre><code>import { chain, filter, fromNullable, map } from 'holo-fn/maybe';\nimport { pipe } from 'rambda';\n\nconst user: { email?: string } | null = { email: 'testuser@example.com' };\n\nconst result = pipe(\n  fromNullable(user),\n  chain((u) =&gt; fromNullable(u.email)),\n  filter((email) =&gt; email.includes('@')),\n  map((email) =&gt; email.toLowerCase())\n);\n\nconsole.log(result); // Just('testuser@example.com')\n</code></pre>"},{"location":"result/","title":"<code>Result&lt;T, E&gt;</code>","text":"<p><code>Result</code> is used to represent computations that either succeed with a value (<code>Ok&lt;T&gt;</code>) or fail with an error (<code>Err&lt;E&gt;</code>).</p> <pre><code>import { Ok } from 'holo-fn/result'\n\nconst result = new Ok&lt;number, string&gt;(10)\n  .map(n =&gt; n + 1)\n  .unwrapOr(0)\n\nconsole.log(result) // 11\n</code></pre>"},{"location":"result/#methods","title":"Methods","text":""},{"location":"result/#mapfn-value-t-u-resultu-e","title":"<code>map(fn: (value: T) =&gt; U): Result&lt;U, E&gt;</code>","text":"<p>Maps over the <code>Ok</code> value. Does nothing for <code>Err</code>.</p> <pre><code>import { Ok, Err } from \"holo-fn/result\";\n\nconst result1 = new Ok(5).map((n) =&gt; n * 2);\nconsole.log(result1.unwrapOr(0)); // 10\n\nconst result2 = new Err&lt;number, string&gt;(\"Error\").map((n) =&gt; n * 2);\nconsole.log(result2.unwrapOr(0)); // 0\n</code></pre>"},{"location":"result/#maperrfn-err-e-f-resultt-f","title":"<code>mapErr(fn: (err: E) =&gt; F): Result&lt;T, F&gt;</code>","text":"<p>Maps over the <code>Err</code> value. Does nothing for <code>Ok</code>.</p> <pre><code>import { Ok, Err } from \"holo-fn/result\";\n\nconst result1 = new Ok(10).mapErr((e) =&gt; `Error: ${e}`);\nconsole.log(result1.unwrapOr(0)); // 10\n\nconst result2 = new Err(\"Fail\").mapErr((e) =&gt; `Mapped error: ${e}`);\nconsole.log(result2.unwrapOr(0)); // 0\n</code></pre>"},{"location":"result/#chainfn-value-t-resultu-e-resultu-e","title":"<code>chain(fn: (value: T) =&gt; Result&lt;U, E&gt;): Result&lt;U, E&gt;</code>","text":"<p>Chains the transformation if the value is <code>Ok</code>. Returns <code>Err</code> otherwise.</p> <pre><code>import { Ok, Err } from \"holo-fn/result\";\n\nconst result1 = new Ok(5)\n  .chain((n) =&gt; new Ok(n * 2))\n  .unwrapOr(0);\nconsole.log(result1); // 10\n\nconst result2 = new Err&lt;number, string&gt;(\"Error\")\n  .chain((n) =&gt; new Ok(n * 2))\n  .unwrapOr(0);\nconsole.log(result2); // 0\n</code></pre>"},{"location":"result/#validatepredicate-value-t-boolean-error-e-resultt-e","title":"<code>validate(predicate: (value: T) =&gt; boolean, error: E): Result&lt;T, E&gt;</code>","text":"<p>Validates the <code>Ok</code> value based on a predicate. If the predicate returns <code>true</code>, keeps the value. If it returns <code>false</code>, converts to <code>Err</code> with the provided error. Does nothing for <code>Err</code>.</p> <pre><code>import { Ok, Err } from \"holo-fn/result\";\n\nconst result1 = new Ok(25).validate((n) =&gt; n &gt;= 18, 'Must be 18+');\nconsole.log(result1.unwrapOr(0)); // 25\n\nconst result2 = new Ok(15).validate((n) =&gt; n &gt;= 18, 'Must be 18+');\nconsole.log(result2.isErr()); // true\n\nconst result3 = new Err&lt;number, string&gt;('Already failed').validate((n) =&gt; n &gt;= 18, 'Must be 18+');\nconsole.log(result3.isErr()); // true (keeps original error)\n</code></pre>"},{"location":"result/#unwrapordefaultvalue-t-t","title":"<code>unwrapOr(defaultValue: T): T</code>","text":"<p>Returns the value of <code>Ok</code>, or the default value for <code>Err</code>.</p> <pre><code>import { Ok, Err } from \"holo-fn/result\";\n\nconst result1 = new Ok(15).unwrapOr(0);\nconsole.log(result1); // 15\n\nconst result2 = new Err(\"Error\").unwrapOr(100);\nconsole.log(result2); // 100\n</code></pre>"},{"location":"result/#isok-boolean","title":"<code>isOk(): boolean</code>","text":"<p>Checks if the value is <code>Ok</code>.</p> <pre><code>import { Ok, Err } from \"holo-fn/result\";\n\nconst result1 = new Ok(5);\nconsole.log(result1.isOk()); // true\n\nconst result2 = new Err(\"Error\");\nconsole.log(result2.isOk()); // false\n</code></pre>"},{"location":"result/#iserr-boolean","title":"<code>isErr(): boolean</code>","text":"<p>Checks if the value is <code>Err</code>.</p> <pre><code>import { Ok, Err } from \"holo-fn/result\";\n\nconst result1 = new Ok(5);\nconsole.log(result1.isErr()); // false\n\nconst result2 = new Err(\"Error\");\nconsole.log(result2.isErr()); // true\n</code></pre>"},{"location":"result/#matchtcases-ok-value-t-t-err-err-e-t-t","title":"<code>match&lt;T&gt;(cases: { ok: (value: T) =&gt; T; err: (err: E) =&gt; T }): T</code>","text":"<p>Matches the value to execute either the <code>ok</code> or <code>err</code> case.</p> <pre><code>import { Ok, Err } from \"holo-fn/result\";\n\nconst result1 = new Ok(10).match({\n  ok: (n) =&gt; `Success: ${n}`,\n  err: (e) =&gt; `Failure: ${e}`,\n});\nconsole.log(result1); // \"Success: 10\"\n\nconst result2 = new Err(\"Error\").match({\n  ok: (n) =&gt; `Success: ${n}`,\n  err: (e) =&gt; `Failure: ${e}`,\n});\nconsole.log(result2); // \"Failure: Error\"\n</code></pre>"},{"location":"result/#equalsother-resultt-e-boolean","title":"<code>equals(other: Result&lt;T, E&gt;): boolean</code>","text":"<p>Compares <code>this</code> to another <code>Result</code>, returns <code>false</code> if the values inside are different.</p> <pre><code>import { Ok, Err } from \"holo-fn/result\";\n\nconst result1 = new Ok(10);\nconsole.log(result1.equals(new Ok(10))); // true\nconsole.log(result1.equals(new Ok(20))); // false\nconsole.log(result1.equals(new Err(\"Error\"))); // false\n\n\nconst result2 = new Err(\"Error\");\nconsole.log(result2.equals(new Err(\"Error\"))); // true\nconsole.log(result1.equals(new Err(\"Error\"))); // false\nconsole.log(result2.equals(new Ok(10))); // false\n</code></pre>"},{"location":"result/#helpers","title":"Helpers","text":""},{"location":"result/#okt-evalue-t-resultt-e","title":"<code>ok&lt;T, E&gt;(value: T): Result&lt;T, E&gt;</code>","text":"<p>Creates an <code>Ok</code> value, representing the success of an operation with a value.</p> <pre><code>import { ok } from 'holo-fn/result';\n\nconst resultValue = ok(10);\nconsole.log(resultValue.unwrapOr(0)); // 10\n</code></pre>"},{"location":"result/#errt-eerror-e-resultt-e","title":"<code>err&lt;T, E&gt;(error: E): Result&lt;T, E&gt;</code>","text":"<p>Creates an <code>Err</code> value, representing a failed operation with an value.</p> <pre><code>import { err } from 'holo-fn/result';\n\nconst resultValue = err(\"Error\");\nconsole.log(resultValue.unwrapOr(\"No error\")); // \"No error\"\n</code></pre>"},{"location":"result/#fromthrowablefn-onerror","title":"<code>fromThrowable(fn, onError?)</code>","text":"<p>Wraps a synchronous function in a <code>Result</code>.</p> <pre><code>import { fromThrowable } from 'holo-fn/result';\n\nconst input = '{\"name\": \"John\", \"age\": 30}'\n\nconst result = fromThrowable(() =&gt; JSON.parse(input), e =&gt; 'Invalid JSON')\n\nconsole.log(result) // _Ok { value: { name: 'John', age: 30 } }\n</code></pre> <ul> <li>Returns <code>Ok&lt;T&gt;</code> if <code>fn()</code> succeeds</li> <li>Returns <code>Err&lt;E&gt;</code> if it throws, using <code>onError</code> if provided</li> </ul>"},{"location":"result/#frompromisepromise-onerror","title":"<code>fromPromise(promise, onError?)</code>","text":"<p>Wraps a <code>Promise&lt;T&gt;</code> into a <code>Promise&lt;Result&lt;T, E&gt;&gt;</code>.</p> <pre><code>import { fromPromise } from 'holo-fn/result';\n\nconst result = await fromPromise(fetch('/api'), e =&gt; 'Network error')\n\nconsole.log(result) // _Err { error: 'Network error' }\n</code></pre> <ul> <li>Resolves to <code>Ok&lt;T&gt;</code> on success</li> <li>Resolves to <code>Err&lt;E&gt;</code> on failure</li> </ul>"},{"location":"result/#fromasyncfn-onerror","title":"<code>fromAsync(fn, onError?)</code>","text":"<p>Same as <code>fromPromise</code>, but lazy \u2014 receives a function returning a Promise.</p> <pre><code>import { fromAsync } from 'holo-fn/result';\n\nconst result = await fromAsync(() =&gt; fetch('/api'), e =&gt; 'Request failed')\n\nconsole.log(result) // _Err { error: 'Request failed' }\n</code></pre> <ul> <li>Allows deferred execution</li> <li>Handles exceptions from <code>async () =&gt; ...</code></li> </ul>"},{"location":"result/#curried-helpers","title":"Curried Helpers","text":""},{"location":"result/#map","title":"<code>map</code>","text":"<p>Curried version of the <code>map</code> function for <code>Result</code>. This allows you to apply a transformation to the Ok value in a more functional style.</p> <pre><code>import { map, Ok } from 'holo-fn/result';\n\nconst result = pipe(\n  new Ok(5),\n  map((x) =&gt; x * 2),\n  (res) =&gt; res.unwrapOr(0)\n);\n\nconsole.log(result); // 10\n</code></pre>"},{"location":"result/#maperr","title":"<code>mapErr</code>","text":"<p>Curried version of <code>mapErr</code> for <code>Result</code>. This allows handling errors in a more functional composition style.</p> <pre><code>import { Err, mapErr, Ok, Result } from 'holo-fn/result';\n\nconst getValue = (value: string | null): Result&lt;string, string&gt; =&gt; {\n    if (value === null) {\n        return new Err(\"Value is null\");\n    }\n    return new Ok(value);\n}\n\nconst result = pipe(\n  getValue(null),\n  mapErr((e) =&gt; `Mapped error: ${e}`),\n  (res) =&gt; res.unwrapOr(\"No value\")\n);\n\nconsole.log(result); // \"No value\"\n</code></pre>"},{"location":"result/#chain","title":"<code>chain</code>","text":"<p>Curried version of <code>chain</code> for <code>Result</code>. This allows you to chain transformations on the Ok value in a functional pipeline.</p> <pre><code>import { chain, Ok } from 'holo-fn/result';\n\nconst result = pipe(\n  new Ok(10),\n  chain((x) =&gt; new Ok(x + 5)),\n  (res) =&gt; res.unwrapOr(0)\n);\n\nconsole.log(result); // 15\n</code></pre>"},{"location":"result/#validate","title":"<code>validate</code>","text":"<p>Curried version of <code>validate</code> for <code>Result</code>. This allows filtering/validating values in a functional pipeline with custom error messages.</p> <pre><code>import { ok, validate, unwrapOr } from 'holo-fn/result';\n\nconst validateAge = (age: number) =&gt;\n  pipe(\n    ok&lt;number, string&gt;(age),\n    validate((x) =&gt; x &gt;= 0, 'Age cannot be negative'),\n    validate((x) =&gt; x &lt;= 150, 'Age too high'),\n    validate((x) =&gt; x &gt;= 18, 'Must be 18+'),\n    unwrapOr(0)\n  );\n\nconsole.log(validateAge(25)); // 25\nconsole.log(validateAge(15)); // 0 (fails validation)\n</code></pre> <p>Common use cases:</p> <pre><code>import { fromThrowable, ok, validate } from \"holo-fn/result\";\nimport { pipe } from \"remeda\";\n\n// Validate email format\nconst validateEmail = (email: string) =&gt;\n  pipe(\n    ok&lt;string, string&gt;(email),\n    validate((s) =&gt; s.length &gt; 0, 'Email is required'),\n    validate((s) =&gt; s.includes('@'), 'Must contain @'),\n    validate((s) =&gt; s.includes('.'), 'Invalid domain')\n  );\n\nconsole.log(validateEmail('testexample.com').unwrapOr('Invalid'));\n\n// Parse and validate numbers\nconst parsePositive = (input: string) =&gt;\n  pipe(\n    fromThrowable(\n      () =&gt; parseInt(input, 10),\n      () =&gt; 'Invalid number'\n    ),\n    validate((n) =&gt; !isNaN(n), 'Not a number'),\n    validate((n) =&gt; n &gt; 0, 'Must be positive')\n  );\n\nconsole.log(parsePositive('42').unwrapOr(0)); // 42\nconsole.log(parsePositive('-5').unwrapOr(0)); // 0\n\n// Validate objects\ntype User = { name: string; age: number };\nconst validateUser = (user: User) =&gt;\n  pipe(\n    ok&lt;User, string&gt;(user),\n    validate((u) =&gt; u.name.length &gt; 0, 'Name required'),\n    validate((u) =&gt; u.age &gt;= 18, 'Must be adult')\n  );\n\nconsole.log(validateUser({ name: 'Alice', age: 30 }).unwrapOr({ name: '', age: 0 }));\nconsole.log(validateUser({ name: '', age: 16 }).unwrapOr({ name: '', age: 0 }));\n</code></pre>"},{"location":"result/#unwrapor","title":"<code>unwrapOr</code>","text":"<p>Curried version of <code>unwrapOr</code> for <code>Result</code>. This provides a cleaner way to unwrap the value in a <code>Result</code>, returning a default value if it's <code>Err</code>.</p> <pre><code>import { Ok, unwrapOr } from 'holo-fn/result';\n\nconst result = pipe(\n  new Ok(42),\n  unwrapOr(0)\n);\n\nconsole.log(result); // 42\n</code></pre>"},{"location":"result/#match","title":"<code>match</code>","text":"<p>Curried version of <code>match</code> for <code>Result</code>. This allows you to handle both <code>Ok</code> and <code>Err</code> in a functional way, providing a clean way to handle both cases.</p> <pre><code>import { match, Ok } from 'holo-fn/result';\n\nconst result = pipe(\n  new Ok(10),\n  match({\n    ok: (v) =&gt; `Success: ${v}`,\n    err: (e) =&gt; `Error: ${e}`\n  })\n);\n\nconsole.log(result); // \"Success: 10\"\n</code></pre>"},{"location":"result/#equals","title":"<code>equals</code>","text":"<p>Curried version of <code>equals</code> for <code>Result</code>. Compares <code>this</code> to another <code>Result</code>, returns <code>false</code> if the values inside are different.</p> <pre><code>import { equals, Ok } from 'holo-fn/result';\nimport { pipe } from 'remeda';\n\nconst result1 = pipe(\n  new Ok(10),\n  equals(new Ok(10)),\n);\n\nconsole.log(result1); // true\n\nconst result2 = pipe(\n  new Ok(10),\n  equals(new Ok(11)),\n);\n\nconsole.log(result2); // false\n</code></pre>"},{"location":"result/#all","title":"<code>all</code>","text":"<p>Combines an array of <code>Result</code> values into a single <code>Result</code>. Returns <code>Ok</code> with all values if all are <code>Ok</code>, or <code>Err</code> with all errors if any are <code>Err</code>.</p> <pre><code>import type { Result } from 'holo-fn';\nimport { all, err, ok } from 'holo-fn/result';\n\nconst result1: Result&lt;number[], unknown[]&gt; = all([ok(1), ok(2), ok(3)]);\nconsole.log(result1.unwrapOr([])); // [1, 2, 3]\n\nconst result2 = all([err('Name required'), err('Email invalid'), ok(25)]);\nconsole.log(\n  result2.match({\n    ok: (v) =&gt; v,\n    err: (e) =&gt; e,\n  })\n); // ['Name required', 'Email invalid']\n\nconst result3 = all([]);\nconsole.log(result3.unwrapOr([])); // []\n</code></pre>"},{"location":"result/#sequence","title":"<code>sequence</code>","text":"<p>Combines an array of <code>Result</code> values into a single <code>Result</code>, stopping at the first error (fail-fast). Returns <code>Ok</code> with all values if all are <code>Ok</code>, or <code>Err</code> with the first error encountered.</p> <p>Unlike <code>all</code> which collects all errors, <code>sequence</code> returns immediately when it finds the first <code>Err</code>.</p> <pre><code>import type { Result } from 'holo-fn';\nimport { err, ok, sequence } from 'holo-fn/result';\n\nconst result1: Result&lt;number[], unknown&gt; = sequence([ok(1), ok(2), ok(3)]);\nconsole.log(result1.unwrapOr([])); // [1, 2, 3]\n\nconst result2 = sequence([\n  ok(1),\n  err('First error'),\n  err('Second error')\n]);\nconsole.log(result2.match({\n  ok: (v) =&gt; v,\n  err: (e) =&gt; e\n})); // 'First error'\n</code></pre>"},{"location":"result/#partition","title":"<code>partition</code>","text":"<p>Separates an array of <code>Result</code> values into two groups: successes (<code>oks</code>) and failures (<code>errs</code>). Always processes all items and returns both arrays.</p> <p>Unlike <code>all</code> and <code>sequence</code> which return a <code>Result</code>, <code>partition</code> returns a plain object with two arrays.</p> <pre><code>import { err, ok, partition } from 'holo-fn/result';\n\nconst results = [\n  ok&lt;number, string&gt;(1),\n  err&lt;number, string&gt;('error1'),\n  ok&lt;number, string&gt;(2),\n  err&lt;number, string&gt;('error2'),\n  ok&lt;number, string&gt;(3),\n];\n\nconst { oks, errs } = partition(results);\nconsole.log(oks); // [1, 2, 3]\nconsole.log(errs); // ['error1', 'error2']\n\nconst { oks: succeeded, errs: failed } = partition(results);\nconsole.log(`\u2713 ${succeeded.length} succeeded`);\nconsole.log(`\u2717 ${failed.length} failed`);\nfailed.forEach((err) =&gt; console.error(err));\n</code></pre>"},{"location":"result/#common-patterns","title":"Common Patterns","text":""},{"location":"result/#error-handling-with-specific-error-types","title":"Error handling with specific error types","text":"<pre><code>import { pipe } from 'rambda';\nimport { err, match, type Result } from 'holo-fn/result';\n\ntype ApiError = 'NOT_FOUND' | 'UNAUTHORIZED' | 'SERVER_ERROR';\n\ntype User = {\n  id: number;\n  name: string;\n};\n\nconst result: Result&lt;User, ApiError&gt; = err('NOT_FOUND');\n\nconst message = pipe(\n  result,\n  match({\n    ok: (user) =&gt; `Welcome ${user.name}`,\n    err: (e) =&gt; {\n      switch (e) {\n        case 'NOT_FOUND':\n          return 'Resource not found';\n        case 'UNAUTHORIZED':\n          return 'Access denied';\n        case 'SERVER_ERROR':\n          return 'Server error occurred';\n      }\n    },\n  })\n);\n\nconsole.log(message);\n</code></pre>"},{"location":"result/#validation-pipelines","title":"Validation pipelines","text":"<pre><code>import { pipe } from 'rambda';\nimport { map, ok, validate } from 'holo-fn/result';\n\nconst validateAge = (age: number) =&gt;\n  pipe(\n    ok&lt;number, string&gt;(age),\n    validate((n) =&gt; n &gt;= 0, 'Age must be positive'),\n    validate((n) =&gt; n &lt;= 150, 'Age must be realistic'),\n    validate((n) =&gt; n &gt;= 18, 'Must be 18 or older'),\n    map((n) =&gt; ({ age: n, isAdult: true }))\n  );\n\nconsole.log(validateAge(25));\n</code></pre>"}]}